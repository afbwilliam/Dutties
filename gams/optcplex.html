<html>
<head>
<title>CPLEX Options</title>
</head>
<body>
<h2>CPLEX Options</h2>
GAMS/Cplex is a GAMS solver that allows users to combine the high
level modeling capabilities of GAMS with the power of Cplex
optimizers. Cplex optimizers are designed to solve large, difficult
problems quickly and with minimal user intervention. Access is
provided (subject to proper licensing) to Cplex solution algorithms
for linear, quadratically constrained and mixed integer programming
problems. While numerous solving options are available, GAMS/Cplex
automatically calculates and sets most options at the best values for
specific problems.
<p>
All Cplex options available through GAMS/Cplex are described in this
document.
<p>For more information about this solver please inspect the
complete <a href="docs/solvers/cplex.pdf">CPLEX manual</a>.

<h2>Summary of CPLEX Options</h2>
<table>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>Preprocessing and General Options</h3></th></tr>
<tr><td><a href="#CPLEXadvind">
advind</a></td>
<td>advanced basis use</td></tr>
<tr><td><a href="#CPLEXaggfill">
aggfill</a></td>
<td>aggregator fill parameter</td></tr>
<tr><td><a href="#CPLEXaggind">
aggind</a></td>
<td>aggregator on/off</td></tr>
<tr><td><a href="#CPLEXclocktype">
clocktype</a></td>
<td>clock type for computation time</td></tr>
<tr><td><a href="#CPLEXcoeredind">
coeredind</a></td>
<td>coefficient reduction on/off</td></tr>
<tr><td><a href="#CPLEXdepind">
depind</a></td>
<td>dependency checker on/off</td></tr>
<tr><td><a href="#CPLEXdettilim">
dettilim</a></td>
<td>deterministic time limit</td></tr>
<tr><td><a href="#CPLEXfeasopt">
feasopt</a></td>
<td>computes a minimum-cost relaxation to make an infeasible model feasible</td></tr>
<tr><td><a href="#CPLEXfeasoptmode">
feasoptmode</a></td>
<td>Mode of FeasOpt</td></tr>
<tr><td><a href="#CPLEX.feaspref">
.feaspref</a></td>
<td>feasibility preference</td></tr>
<tr><td><a href="#CPLEXinteractive">
interactive</a></td>
<td>allow interactive option setting after a Control-C</td></tr>
<tr><td><a href="#CPLEXlpmethod">
lpmethod</a></td>
<td>algorithm to be used for LP problems</td></tr>
<tr><td><a href="#CPLEXmemoryemphasis">
memoryemphasis</a></td>
<td>Reduces use of memory</td></tr>
<tr><td><a href="#CPLEXnames">
names</a></td>
<td>load GAMS names into Cplex</td></tr>
<tr><td><a href="#CPLEXnumericalemphasis">
numericalemphasis</a></td>
<td>emphasizes precision in numerically unstable or difficult problems</td></tr>
<tr><td><a href="#CPLEXobjrng">
objrng</a></td>
<td>do objective ranging</td></tr>
<tr><td><a href="#CPLEXparallelmode">
parallelmode</a></td>
<td>parallel optimization mode</td></tr>
<tr><td><a href="#CPLEXpredual">
predual</a></td>
<td>give dual problem to the optimizer</td></tr>
<tr><td><a href="#CPLEXpreind">
preind</a></td>
<td>turn presolver on/off</td></tr>
<tr><td><a href="#CPLEXprelinear">
prelinear</a></td>
<td>linear reduction indicator</td></tr>
<tr><td><a href="#CPLEXprepass">
prepass</a></td>
<td>number of presolve applications to perform</td></tr>
<tr><td><a href="#CPLEXprintoptions">
printoptions</a></td>
<td>list values of all options to GAMS listing file</td></tr>
<tr><td><a href="#CPLEXqpmethod">
qpmethod</a></td>
<td>algorithm to be used for QP problems</td></tr>
<tr><td><a href="#CPLEXreduce">
reduce</a></td>
<td>primal and dual reduction type</td></tr>
<tr><td><a href="#CPLEXrelaxpreind">
relaxpreind</a></td>
<td>presolve for initial relaxation on/off</td></tr>
<tr><td><a href="#CPLEXrerun">
rerun</a></td>
<td>rerun problem if presolve infeasible or unbounded</td></tr>
<tr><td><a href="#CPLEXrhsrng">
rhsrng</a></td>
<td>do right-hand-side ranging</td></tr>
<tr><td><a href="#CPLEXrngrestart">
rngrestart</a></td>
<td>write GAMS readable ranging information file</td></tr>
<tr><td><a href="#CPLEXscaind">
scaind</a></td>
<td>matrix scaling on/off</td></tr>
<tr><td><a href="#CPLEXsolutiontarget">
solutiontarget</a></td>
<td>type of solution when solving a nonconvex continuous quadratic model</td></tr>
<tr><td><a href="#CPLEXthreads">
threads</a></td>
<td>global default thread count</td></tr>
<tr><td><a href="#CPLEXtilim">
tilim</a></td>
<td>overrides the GAMS ResLim option</td></tr>
<tr><td><a href="#CPLEXtuning">
tuning</a></td>
<td>invokes parameter tuning tool</td></tr>
<tr><td><a href="#CPLEXtuningdettilim">
tuningdettilim</a></td>
<td>tuning deterministic time limit per model or suite</td></tr>
<tr><td><a href="#CPLEXtuningdisplay">
tuningdisplay</a></td>
<td>level of information reported by the tuning tool</td></tr>
<tr><td><a href="#CPLEXtuningmeasure">
tuningmeasure</a></td>
<td>measure for evaluating progress for a suite of models</td></tr>
<tr><td><a href="#CPLEXtuningrepeat">
tuningrepeat</a></td>
<td>number of times tuning is to be repeated on perturbed versions</td></tr>
<tr><td><a href="#CPLEXtuningtilim">
tuningtilim</a></td>
<td>tuning time limit per model or suite</td></tr>
<tr><td><a href="#CPLEXworkdir">
workdir</a></td>
<td>directory for working files</td></tr>
<tr><td><a href="#CPLEXworkmem">
workmem</a></td>
<td>memory available for working storage</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>Simplex Algorithmic Options</h3></th></tr>
<tr><td><a href="#CPLEXcraind">
craind</a></td>
<td>crash strategy (used to obtain starting basis)</td></tr>
<tr><td><a href="#CPLEXdpriind">
dpriind</a></td>
<td>dual simplex pricing</td></tr>
<tr><td><a href="#CPLEXepper">
epper</a></td>
<td>perturbation constant</td></tr>
<tr><td><a href="#CPLEXiis">
iis</a></td>
<td>run the IIS finder if the problem is infeasible</td></tr>
<tr><td><a href="#CPLEXnetfind">
netfind</a></td>
<td>attempt network extraction</td></tr>
<tr><td><a href="#CPLEXnetppriind">
netppriind</a></td>
<td>network simplex pricing</td></tr>
<tr><td><a href="#CPLEXperind">
perind</a></td>
<td>force initial perturbation</td></tr>
<tr><td><a href="#CPLEXperlim">
perlim</a></td>
<td>number of stalled iterations before perturbation</td></tr>
<tr><td><a href="#CPLEXppriind">
ppriind</a></td>
<td>primal simplex pricing</td></tr>
<tr><td><a href="#CPLEXpricelim">
pricelim</a></td>
<td>pricing candidate list</td></tr>
<tr><td><a href="#CPLEXreinv">
reinv</a></td>
<td>refactorization frequency</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>Simplex Limit Options</h3></th></tr>
<tr><td><a href="#CPLEXitlim">
itlim</a></td>
<td>iteration limit</td></tr>
<tr><td><a href="#CPLEXnetitlim">
netitlim</a></td>
<td>iteration limit for network simplex</td></tr>
<tr><td><a href="#CPLEXobjllim">
objllim</a></td>
<td>objective function lower limit</td></tr>
<tr><td><a href="#CPLEXobjulim">
objulim</a></td>
<td>objective function upper limit</td></tr>
<tr><td><a href="#CPLEXsinglim">
singlim</a></td>
<td>limit on singularity repairs</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>Simplex Tolerance Options</h3></th></tr>
<tr><td><a href="#CPLEXepmrk">
epmrk</a></td>
<td>Markowitz pivot tolerance</td></tr>
<tr><td><a href="#CPLEXepopt">
epopt</a></td>
<td>optimality tolerance</td></tr>
<tr><td><a href="#CPLEXeprhs">
eprhs</a></td>
<td>feasibility tolerance</td></tr>
<tr><td><a href="#CPLEXnetepopt">
netepopt</a></td>
<td>optimality tolerance for the network simplex method</td></tr>
<tr><td><a href="#CPLEXneteprhs">
neteprhs</a></td>
<td>feasibility tolerance for the network simplex method</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>Barrier Specific Options</h3></th></tr>
<tr><td><a href="#CPLEXbaralg">
baralg</a></td>
<td>algorithm selection</td></tr>
<tr><td><a href="#CPLEXbarcolnz">
barcolnz</a></td>
<td>dense column handling</td></tr>
<tr><td><a href="#CPLEXbarcrossalg">
barcrossalg</a></td>
<td>barrier crossover method</td></tr>
<tr><td><a href="#CPLEXbarepcomp">
barepcomp</a></td>
<td>convergence tolerance</td></tr>
<tr><td><a href="#CPLEXbargrowth">
bargrowth</a></td>
<td>unbounded face detection</td></tr>
<tr><td><a href="#CPLEXbaritlim">
baritlim</a></td>
<td>iteration limit</td></tr>
<tr><td><a href="#CPLEXbarmaxcor">
barmaxcor</a></td>
<td>maximum correction limit</td></tr>
<tr><td><a href="#CPLEXbarobjrng">
barobjrng</a></td>
<td>maximum objective function</td></tr>
<tr><td><a href="#CPLEXbarorder">
barorder</a></td>
<td>row ordering algorithm selection</td></tr>
<tr><td><a href="#CPLEXbarqcpepcomp">
barqcpepcomp</a></td>
<td>convergence tolerance for the barrier optimizer for QCPs</td></tr>
<tr><td><a href="#CPLEXbarstartalg">
barstartalg</a></td>
<td>barrier starting point algorithm</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>Sifting Specific Options</h3></th></tr>
<tr><td><a href="#CPLEXsiftalg">
siftalg</a></td>
<td>sifting subproblem algorithm</td></tr>
<tr><td><a href="#CPLEXsiftitlim">
siftitlim</a></td>
<td>limit on sifting iterations</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>MIP Algorithmic Options</h3></th></tr>
<tr><td><a href="#CPLEXbbinterval">
bbinterval</a></td>
<td>best bound interval</td></tr>
<tr><td><a href="#CPLEXbndstrenind">
bndstrenind</a></td>
<td>bound strengthening</td></tr>
<tr><td><a href="#CPLEXbrdir">
brdir</a></td>
<td>set branching direction</td></tr>
<tr><td><a href="#CPLEXbttol">
bttol</a></td>
<td>backtracking limit</td></tr>
<tr><td><a href="#CPLEXcliques">
cliques</a></td>
<td>clique cut generation</td></tr>
<tr><td><a href="#CPLEXcovers">
covers</a></td>
<td>cover cut generation</td></tr>
<tr><td><a href="#CPLEXcutlo">
cutlo</a></td>
<td>lower cutoff for tree search</td></tr>
<tr><td><a href="#CPLEXcuts">
cuts</a></td>
<td>default cut generation</td></tr>
<tr><td><a href="#CPLEXcutsfactor">
cutsfactor</a></td>
<td>cut limit</td></tr>
<tr><td><a href="#CPLEXcutup">
cutup</a></td>
<td>upper cutoff for tree search</td></tr>
<tr><td><a href="#CPLEXdisjcuts">
disjcuts</a></td>
<td>disjunctive cuts generation</td></tr>
<tr><td><a href="#CPLEXdivetype">
divetype</a></td>
<td>MIP dive strategy</td></tr>
<tr><td><a href="#CPLEXeachcutlim">
eachcutlim</a></td>
<td>Sets a limit for each type of cut</td></tr>
<tr><td><a href="#CPLEXflowcovers">
flowcovers</a></td>
<td>flow cover cut generation</td></tr>
<tr><td><a href="#CPLEXflowpaths">
flowpaths</a></td>
<td>flow path cut generation</td></tr>
<tr><td><a href="#CPLEXfpheur">
fpheur</a></td>
<td>feasibility pump heuristic</td></tr>
<tr><td><a href="#CPLEXfraccuts">
fraccuts</a></td>
<td>Gomory fractional cut generation</td></tr>
<tr><td><a href="#CPLEXgubcovers">
gubcovers</a></td>
<td>GUB cover cut generation</td></tr>
<tr><td><a href="#CPLEXheurfreq">
heurfreq</a></td>
<td>heuristic frequency</td></tr>
<tr><td><a href="#CPLEXimplbd">
implbd</a></td>
<td>implied bound cut generation</td></tr>
<tr><td><a href="#CPLEXlbheur">
lbheur</a></td>
<td>local branching heuristic</td></tr>
<tr><td><a href="#CPLEXmcfcuts">
mcfcuts</a></td>
<td>multi-commodity flow cut generation</td></tr>
<tr><td><a href="#CPLEXmipemphasis">
mipemphasis</a></td>
<td>MIP solution tactics</td></tr>
<tr><td><a href="#CPLEXmipkappastats">
mipkappastats</a></td>
<td>MIP kappa computation</td></tr>
<tr><td><a href="#CPLEXmipordind">
mipordind</a></td>
<td>priority list on/off</td></tr>
<tr><td><a href="#CPLEXmipordtype">
mipordtype</a></td>
<td>priority order generation</td></tr>
<tr><td><a href="#CPLEXmipsearch">
mipsearch</a></td>
<td>search strategy for mixed integer programs</td></tr>
<tr><td><a href="#CPLEXmipstart">
mipstart</a></td>
<td>use mip starting values</td></tr>
<tr><td><a href="#CPLEXmiqcpstrat">
miqcpstrat</a></td>
<td>MIQCP relaxation choice</td></tr>
<tr><td><a href="#CPLEXmircuts">
mircuts</a></td>
<td>mixed integer rounding cut generation</td></tr>
<tr><td><a href="#CPLEXnodefileind">
nodefileind</a></td>
<td>node storage file indicator</td></tr>
<tr><td><a href="#CPLEXnodesel">
nodesel</a></td>
<td>node selection strategy</td></tr>
<tr><td><a href="#CPLEXpreslvnd">
preslvnd</a></td>
<td>node presolve selector</td></tr>
<tr><td><a href="#CPLEXprobe">
probe</a></td>
<td>perform probing before solving a MIP</td></tr>
<tr><td><a href="#CPLEXqpmakepsdind">
qpmakepsdind</a></td>
<td>adjust MIQP formulation to make the quadratic matrix positive-semi-definite</td></tr>
<tr><td><a href="#CPLEXrelaxfixedinfeas">
relaxfixedinfeas</a></td>
<td>access small infeasibilties in the solve of the fixed problem</td></tr>
<tr><td><a href="#CPLEXrepeatpresolve">
repeatpresolve</a></td>
<td>reapply presolve at root after preprocessing</td></tr>
<tr><td><a href="#CPLEXrinsheur">
rinsheur</a></td>
<td>relaxation induced neighborhood search frequency</td></tr>
<tr><td><a href="#CPLEXsolvefinal">
solvefinal</a></td>
<td>switch to solve the problem with fixed discrete variables</td></tr>
<tr><td><a href="#CPLEXstartalg">
startalg</a></td>
<td>MIP starting algorithm</td></tr>
<tr><td><a href="#CPLEXstrongcandlim">
strongcandlim</a></td>
<td>size of the candidates list for strong branching</td></tr>
<tr><td><a href="#CPLEXstrongitlim">
strongitlim</a></td>
<td>limit on iterations per branch for strong branching</td></tr>
<tr><td><a href="#CPLEXsubalg">
subalg</a></td>
<td>algorithm for subproblems</td></tr>
<tr><td><a href="#CPLEXsubmipnodelim">
submipnodelim</a></td>
<td>limit on number of nodes in an RINS subMIP</td></tr>
<tr><td><a href="#CPLEXsymmetry">
symmetry</a></td>
<td>symmetry breaking cuts</td></tr>
<tr><td><a href="#CPLEXvarsel">
varsel</a></td>
<td>variable selection strategy at each node</td></tr>
<tr><td><a href="#CPLEXzerohalfcuts">
zerohalfcuts</a></td>
<td>zero-half cuts</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>MIP Limit Options</h3></th></tr>
<tr><td><a href="#CPLEXaggcutlim">
aggcutlim</a></td>
<td>aggrigation limit for cut generation</td></tr>
<tr><td><a href="#CPLEXauxrootthreads">
auxrootthreads</a></td>
<td>number of threads for auxiliary tasks at the root node</td></tr>
<tr><td><a href="#CPLEXcutpass">
cutpass</a></td>
<td>maximum number of cutting plane passes</td></tr>
<tr><td><a href="#CPLEXfraccand">
fraccand</a></td>
<td>candidate limit for generating Gomory fractional cuts</td></tr>
<tr><td><a href="#CPLEXfracpass">
fracpass</a></td>
<td>maximum number of passes for generating Gomory fractional cuts</td></tr>
<tr><td><a href="#CPLEXintsollim">
intsollim</a></td>
<td>maximum number of integer solutions</td></tr>
<tr><td><a href="#CPLEXnodelim">
nodelim</a></td>
<td>maximum number of nodes to solve</td></tr>
<tr><td><a href="#CPLEXpolishafterdettime">
polishafterdettime</a></td>
<td>Deterministic time before starting to polish a feasible solution</td></tr>
<tr><td><a href="#CPLEXpolishafterepagap">
polishafterepagap</a></td>
<td>Absolute MIP gap before starting to polish a feasible solution</td></tr>
<tr><td><a href="#CPLEXpolishafterepgap">
polishafterepgap</a></td>
<td>Relative MIP gap before starting to polish a solution</td></tr>
<tr><td><a href="#CPLEXpolishafterintsol">
polishafterintsol</a></td>
<td>MIP integer solutions to find before starting to polish a feasible solution</td></tr>
<tr><td><a href="#CPLEXpolishafternode">
polishafternode</a></td>
<td>Nodes to process before starting to polish a feasible solution</td></tr>
<tr><td><a href="#CPLEXpolishaftertime">
polishaftertime</a></td>
<td>Time before starting to polish a feasible solution</td></tr>
<tr><td><a href="#CPLEXprobedettime">
probedettime</a></td>
<td>deterministic time spent probing</td></tr>
<tr><td><a href="#CPLEXprobetime">
probetime</a></td>
<td>time spent probing</td></tr>
<tr><td><a href="#CPLEXrepairtries">
repairtries</a></td>
<td>try to repair infeasible MIP start</td></tr>
<tr><td><a href="#CPLEXtrelim">
trelim</a></td>
<td>maximum space in memory for tree</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>MIP Solution Pool Options</h3></th></tr>
<tr><td><a href="#CPLEX.divflt">
.divflt</a></td>
<td>solution pool range filter coefficients</td></tr>
<tr><td><a href="#CPLEXdivfltlo">
divfltlo</a></td>
<td>lower bound on diversity</td></tr>
<tr><td><a href="#CPLEXdivfltup">
divfltup</a></td>
<td>upper bound on diversity</td></tr>
<tr><td><a href="#CPLEXpopulatelim">
populatelim</a></td>
<td>limit of solutions generated for the solution pool by populate method</td></tr>
<tr><td><a href="#CPLEXrandomseed">
randomseed</a></td>
<td>sets the random seed differently for diversity of solutions</td></tr>
<tr><td><a href="#CPLEXreadflt">
readflt</a></td>
<td>reads Cplex solution pool filter file</td></tr>
<tr><td><a href="#CPLEXsolnpool">
solnpool</a></td>
<td>solution pool file name</td></tr>
<tr><td><a href="#CPLEXsolnpoolagap">
solnpoolagap</a></td>
<td>absolute tolerance for the solutions in the solution pool</td></tr>
<tr><td><a href="#CPLEXsolnpoolcapacity">
solnpoolcapacity</a></td>
<td>limits of solutions kept in the solution pool</td></tr>
<tr><td><a href="#CPLEXsolnpoolgap">
solnpoolgap</a></td>
<td>relative tolerance for the solutions in the solution pool</td></tr>
<tr><td><a href="#CPLEXsolnpoolintensity">
solnpoolintensity</a></td>
<td>solution pool intensity for ability to produce multiple solutions</td></tr>
<tr><td><a href="#CPLEXsolnpoolpop">
solnpoolpop</a></td>
<td>methods to populate the solution pool</td></tr>
<tr><td><a href="#CPLEXsolnpoolpopdel">
solnpoolpopdel</a></td>
<td>file with solution numbers to delete from the solution pool</td></tr>
<tr><td><a href="#CPLEXsolnpoolpoprepeat">
solnpoolpoprepeat</a></td>
<td>method to decide if populating the solution should be repeated</td></tr>
<tr><td><a href="#CPLEXsolnpoolprefix">
solnpoolprefix</a></td>
<td>file name prefix for GDX solution files</td></tr>
<tr><td><a href="#CPLEXsolnpoolreplace">
solnpoolreplace</a></td>
<td>strategy for replacing a solution in the solution pool</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>MIP Tolerance Options</h3></th></tr>
<tr><td><a href="#CPLEXepagap">
epagap</a></td>
<td>absolute stopping tolerance</td></tr>
<tr><td><a href="#CPLEXepgap">
epgap</a></td>
<td>relative stopping tolerance</td></tr>
<tr><td><a href="#CPLEXepint">
epint</a></td>
<td>integrality tolerance</td></tr>
<tr><td><a href="#CPLEXobjdif">
objdif</a></td>
<td>overrides GAMS Cheat parameter</td></tr>
<tr><td><a href="#CPLEXrelobjdif">
relobjdif</a></td>
<td>relative cheat parameter</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>Output Options</h3></th></tr>
<tr><td><a href="#CPLEXbardisplay">
bardisplay</a></td>
<td>progress display level</td></tr>
<tr><td><a href="#CPLEXclonelog">
clonelog</a></td>
<td>enable clone logs</td></tr>
<tr><td><a href="#CPLEXmipdisplay">
mipdisplay</a></td>
<td>progress display level</td></tr>
<tr><td><a href="#CPLEXmipinterval">
mipinterval</a></td>
<td>progress display interval</td></tr>
<tr><td><a href="#CPLEXmpslongnum">
mpslongnum</a></td>
<td>MPS file format precision of numeric output</td></tr>
<tr><td><a href="#CPLEXnetdisplay">
netdisplay</a></td>
<td>network display level</td></tr>
<tr><td><a href="#CPLEXquality">
quality</a></td>
<td>write solution quality statistics</td></tr>
<tr><td><a href="#CPLEXsiftdisplay">
siftdisplay</a></td>
<td>sifting display level</td></tr>
<tr><td><a href="#CPLEXsimdisplay">
simdisplay</a></td>
<td>simplex display level</td></tr>
<tr><td><a href="#CPLEXwritebas">
writebas</a></td>
<td>produce a Cplex basis file</td></tr>
<tr><td><a href="#CPLEXwriteflt">
writeflt</a></td>
<td>produce a Cplex solution pool filter file</td></tr>
<tr><td><a href="#CPLEXwritelp">
writelp</a></td>
<td>produce a Cplex LP file</td></tr>
<tr><td><a href="#CPLEXwritemps">
writemps</a></td>
<td>produce a Cplex MPS file</td></tr>
<tr><td><a href="#CPLEXwritemst">
writemst</a></td>
<td>produce a Cplex mst file</td></tr>
<tr><td><a href="#CPLEXwriteord">
writeord</a></td>
<td>produce a Cplex ord file</td></tr>
<tr><td><a href="#CPLEXwriteparam">
writeparam</a></td>
<td>produce a Cplex parameter file with all active options</td></tr>
<tr><td><a href="#CPLEXwritepre">
writepre</a></td>
<td>produce a Cplex LP/MPS/SAV file of the presolved problem</td></tr>
<tr><td><a href="#CPLEXwritesav">
writesav</a></td>
<td>produce a Cplex binary problem file</td></tr>
<tr><th height=75 valign=bottom colspan=2 align=left><h3>BCH Facility Options</h3></th></tr>
<tr><td><a href="#CPLEXuserincbcall">
userincbcall</a></td>
<td>The GAMS command line to call the incumbent checking program</td></tr></table>
<h2>Detailed Descriptions of CPLEX Options</h2>

<h4><a name="CPLEXadvind">
advind</a>
<i> (integer)</i> advanced basis use</h4><p>

Use an Advanced Basis. GAMS/Cplex will automatically use an advanced
basis from a previous solve statement. The GAMS <i>Bratio</i>
option can be used to specify when not to use an advanced basis. The
Cplex option <i>advind</i> can be used to ignore a basis passed on by GAMS
(it overrides <i>Bratio</i>).

<br><i>(default = determined by GAMS Bratio)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Do not use advanced basis</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Use advanced basis if available</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Crash an advanced basis if available (use basis with presolve)</td></tr>
</table>

<h4><a name="CPLEXaggcutlim">
aggcutlim</a>
<i> (integer)</i> aggrigation limit for cut generation</h4><p>

Limits the number of constraints that can be aggregated for generating
flow cover and mixed integer rounding cuts. For most purposes, the
default will be satisfactory.

<br><i>(default = 3)</i>

<h4><a name="CPLEXaggfill">
aggfill</a>
<i> (integer)</i> aggregator fill parameter</h4><p>

Aggregator fill limit. If the net result of a single substitution is
more non-zeros than the setting of the <i>aggfill</i> parameter, the
substitution will not be made.

<br><i>(default = 10)</i>

<h4><a name="CPLEXaggind">
aggind</a>
<i> (integer)</i> aggregator on/off</h4><p>

This option, when set to a nonzero value, will cause the Cplex
aggregator to use substitution where possible to reduce the number of
rows and columns in the problem. If set to a positive value, the
aggregator will be applied the specified number of times, or until no
more reductions are possible. At the default value of -1, the
aggregator is applied once for linear programs and an unlimited number
of times for mixed integer problems.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Once for LP, unlimited for MIP</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Do not use</td></tr>
</table>

<h4><a name="CPLEXauxrootthreads">
auxrootthreads</a>
<i> (integer)</i> number of threads for auxiliary tasks at the root node</h4><p>

Partitions the number of threads for CPLEX to use for auxiliary tasks
while it solves the root node of a problem.  On a system that offers <i>N</i>
processors or <i>N</i> global threads, if you set this parameter to <i>n</i>, where
<i>N&gt;n&gt;0</i> then CPLEX uses at most <i>n</i> threads for auxiliary tasks and at
most <i>N-n</i> threads to solve the root node.  See also the parameter
<a href="#CPLEXthreads">threads</a>.
<p>
You cannot set <i>n</i>, the value of this parameter, to a
value greater than or equal to <i>N</i>, the number of processors or global
threads offered on your system. In other words, when you set this
parameter to a value other than its default, that value must be
strictly less than the number of processors or global threads on your
system.  Independent of the auxiliary root threads parameter, CPLEX
will never use more threads than those defined by the global default
thread count parameter. CPLEX also makes sure that there
is at least one thread available for the main root tasks. For example,
if you set the global threads parameter to 3 and the auxiliary root
threads parameter to 4, CPLEX still uses only two threads for
auxiliary root tasks in order to keep one thread available for the
main root tasks.  At its default value, 0 (zero), CPLEX automatically
chooses the number of threads to use for the primary root tasks and
for auxiliary tasks. The number of threads that CPLEX uses to solve
the root node depends on several factors: 1) the number of processors
available on your system; 2) the number of threads available to your
application on your system (for example, as a result of limited
resources or competition with other applications); 3) the value of the
global default thread count parameter <a href="#CPLEXthreads">threads</a>.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Off: do not use additional threads for auxiliary tasks</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic: let CPLEX choose the number of threads to use</td></tr>
<tr valign="top"><td width=20 align=right>N>n>0</td><td>Use n threads for auxiliary root tasks</td></tr>
</table>

<h4><a name="CPLEXbaralg">
baralg</a>
<i> (integer)</i> algorithm selection</h4><p>

Selects which barrier algorithm to use. The default setting of 0 uses
the infeasibility-estimate start algorithm for MIP subproblems and the
standard barrier algorithm, option 3, for other cases. The standard
barrier algorithm is almost always fastest. The alternative
algorithms, options 1 and 2, may eliminate numerical difficulties
related to infeasibility, but will generally be slower.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Same as 1 for MIP subproblems, 3 otherwise</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Infeasibility-estimate start</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Infeasibility-constant start</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>standard barrier algorithm</td></tr>
</table>

<h4><a name="CPLEXbarcolnz">
barcolnz</a>
<i> (integer)</i> dense column handling</h4><p>

Determines whether or not columns are considered dense for special
barrier algorithm handling. At the default setting of 0, this
parameter is determined dynamically. Values above 0 specify the number
of entries in columns to be considered as dense.

<br><i>(default = 0)</i>

<h4><a name="CPLEXbarcrossalg">
barcrossalg</a>
<i> (integer)</i> barrier crossover method</h4><p>

Selects which, if any, crossover method is used at the end of a
barrier optimization.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>No crossover</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Primal crossover</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Dual crossover</td></tr>
</table>

<h4><a name="CPLEXbardisplay">
bardisplay</a>
<i> (integer)</i> progress display level</h4><p>

Determines the level of progress information to be displayed while the
barrier method is running.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>No progress information</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Display normal information</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Display diagnostic information</td></tr>
</table>

<h4><a name="CPLEXbarepcomp">
barepcomp</a>
<i> (real)</i> convergence tolerance</h4><p>

Determines the tolerance on complementarity for convergence of the
barrier algorithm. The algorithm will terminate with an optimal
solution if the relative complementarity is smaller than this value.

<br><i>(default = 1e-008)</i>

<h4><a name="CPLEXbargrowth">
bargrowth</a>
<i> (real)</i> unbounded face detection</h4><p>

Used by the barrier algorithm to detect unbounded optimal faces. At
higher values, the barrier algorithm will be less likely to conclude
that the problem has an unbounded optimal face, but more likely to
have numerical difficulties if the problem does have an unbounded
face.

<br><i>(default = 1e+012)</i>

<h4><a name="CPLEXbaritlim">
baritlim</a>
<i> (integer)</i> iteration limit</h4><p>

Determines the maximum number of iterations for the barrier
algorithm. When set to 0, no Barrier iterations occur, but problem
<i>setup</i> occurs and information about the setup is displayed (such
as Cholesky factorization information). When left at the default
value, there is no explicit limit on the number of iterations.

<br><i>(default = large)</i>

<h4><a name="CPLEXbarmaxcor">
barmaxcor</a>
<i> (integer)</i> maximum correction limit</h4><p>

Specifies the maximum number of centering corrections that should be
done on each iteration. Larger values may improve the numerical
performance of the barrier algorithm at the expense of computation
time. The default of -1 means the number is automatically determined.

<br><i>(default = -1)</i>

<h4><a name="CPLEXbarobjrng">
barobjrng</a>
<i> (real)</i> maximum objective function</h4><p>

Determines the maximum absolute value of the objective function. The
barrier algorithm looks at this limit to detect unbounded problems.

<br><i>(default = 1e+020)</i>

<h4><a name="CPLEXbarorder">
barorder</a>
<i> (integer)</i> row ordering algorithm selection</h4><p>

Determines the ordering algorithm to be used by the barrier method. By
default, Cplex attempts to choose the most effective of the available
alternatives. Higher numbers tend to favor better orderings at the
expense of longer ordering runtimes.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Approximate Minimum Degree (AMD)</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Approximate Minimum Fill (AMF)</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Nested Dissection (ND)</td></tr>
</table>

<h4><a name="CPLEXbarqcpepcomp">
barqcpepcomp</a>
<i> (real)</i> convergence tolerance for the barrier optimizer for QCPs</h4><p>


<br><i>Range: [1e-012,1e+075]</i>

<br><i>(default = 1e-007)</i>

<h4><a name="CPLEXbarstartalg">
barstartalg</a>
<i> (integer)</i> barrier starting point algorithm</h4><p>

This option sets the algorithm to be used to compute the initial
starting point for the barrier solver. The default starting point is
satisfactory for most problems. Since the default starting point is
tuned for primal problems, using the other starting points may be
worthwhile in conjunction with the <i>predual</i> parameter.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>1</td><td>default primal, dual is 0</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>default primal, estimate dual</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>primal average, dual is 0</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>primal average, estimate dual</td></tr>
</table>

<h4><a name="CPLEXbbinterval">
bbinterval</a>
<i> (integer)</i> best bound interval</h4><p>

Set interval for selecting a best bound node when doing a best
estimate search. Active only when <i>nodesel</i> is 2 (best
estimate). Decreasing this interval may be useful when best estimate
is finding good solutions but making little progress in moving the
bound. Increasing this interval may help when the best estimate node
selection is not finding any good integer solutions. Setting the
interval to 1 is equivalent to setting <i>nodesel</i> to 1.

<br><i>(default = 7)</i>

<h4><a name="CPLEXbndstrenind">
bndstrenind</a>
<i> (integer)</i> bound strengthening</h4><p>

Use bound strengthening when solving mixed integer problems. Bound
strengthening tightens the bounds on variables, perhaps to the point
where the variable can be fixed and thus removed from consideration
during the branch and bound algorithm. This reduction is usually
beneficial, but occasionally, due to its iterative nature, takes a long
time.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Determine automatically</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Don't use bound strengthening</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Use bound strengthening</td></tr>
</table>

<h4><a name="CPLEXbrdir">
brdir</a>
<i> (integer)</i> set branching direction</h4><p>

Used to decide which branch (up or down) should be taken first at each
node.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Down branch selected first</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Algorithm decides</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Up branch selected first</td></tr>
</table>

<h4><a name="CPLEXbttol">
bttol</a>
<i> (real)</i> backtracking limit</h4><p>

This option controls how often backtracking is done during the
branching process. At each node, Cplex compares the objective function
value or estimated integer objective value to these values at parent
nodes; the value of the <i>bttol</i> parameter dictates how much relative
degradation is tolerated before backtracking.  Lower values tend to
increase the amount of backtracking, making the search more of a pure
best-bound search. Higher values tend to decrease the amount of
backtracking, making the search more of a depth-first search. This
parameter is used only once a first integer solution is found or when
a cutoff has been specified.

<br><i>Range: [0,1]</i>

<br><i>(default = 0.9999)</i>

<h4><a name="CPLEXcliques">
cliques</a>
<i> (integer)</i> clique cut generation</h4><p>

Determines whether or not clique cuts should be generated during
optimization.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate clique cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate clique cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate clique cuts aggressively</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Generate clique cuts very aggressively</td></tr>
</table>

<h4><a name="CPLEXclocktype">
clocktype</a>
<i> (integer)</i> clock type for computation time</h4><p>

Decides how computation times are measured for both reporting
performance and terminating optimization when a time limit has been
set. Small variations in measured time on identical runs may be
expected on any computer system with any setting of this parameter.
The default setting 0 (zero) allows CPLEX to choose wall clock time
when other parameters invoke parallel optimization and to choose CPU
time when other parameters enforce sequential (not parallel)
optimization. GAMS/Cplex works with wall time on Windows also for
sequential optimization unless this option instructs to measure time
differently.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>CPU time</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Wall clock time</td></tr>
</table>

<h4><a name="CPLEXclonelog">
clonelog</a>
<i> (integer)</i> enable clone logs</h4><p>

The clone logs contain information normally recorded in the ordinary
log file but inconvenient to send through the normal log channel in
case of parallel execution. The information likely to be of most
interest to you are special messages, such as error messages, that
result from calls to the LP optimizers called for the subproblems.
The clone log files are named cloneK.log, where <i>K</i> is the index
of the clone, ranging from 0 (zero) to the number of threads minus
one. Since the clones are created at each call to a parallel
optimizer and discarded when it exits, the clone logs are opened at
each call and closed at each exit. The clone log files are not
removed when the clones themselves are discarded.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Clone log files off</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Clone log files on</td></tr>
</table>

<h4><a name="CPLEXcoeredind">
coeredind</a>
<i> (integer)</i> coefficient reduction on/off</h4><p>

Coefficient reduction is a technique used when presolving mixed
integer programs. The benefit is to improve the objective value of the
initial (and subsequent) linear programming relaxations by reducing
the number of non-integral vertices. However, the linear programs
generated at each node may become more difficult to solve.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Do not use coefficient reduction</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Reduce only to integral coefficients</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Reduce all potential coefficients</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Reduce aggressively with tilting</td></tr>
</table>

<h4><a name="CPLEXcovers">
covers</a>
<i> (integer)</i> cover cut generation</h4><p>

Determines whether or not cover cuts should be generated during
optimization.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate cover cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate cover cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate cover cuts aggressively</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Generate cover cuts very aggressively</td></tr>
</table>

<h4><a name="CPLEXcraind">
craind</a>
<i> (integer)</i> crash strategy (used to obtain starting basis)</h4><p>

The crash option biases the way Cplex orders variables relative to the
objective function when selecting an initial basis.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Primal: alternate ways of using objective coefficients. Dual: aggressive starting basis</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Primal: ignore objective coefficients during crash.     Dual: aggressive starting basis</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Primal: alternate ways of using objective coefficients. Dual: default starting basis</td></tr>
</table>

<h4><a name="CPLEXcutlo">
cutlo</a>
<i> (real)</i> lower cutoff for tree search</h4><p>

Sets the lower cutoff tolerance. When the problem is a maximization
problem, CPLEX cuts off or discards solutions that are less than the
specified cutoff value. If the model has no solution with an objective
value greater than or equal to the cutoff value, then CPLEX declares
the model infeasible. In other words, setting the lower cutoff value c
for a maximization problem is similar to adding this constraint to the
objective function of the model: <tt>obj>=c</tt>.
<p>
This option overrides the GAMS Cutoff setting.
<p>
This parameter is not effective with FeasOpt. FeasOpt cannot analyze
an infeasibility introduced by this parameter. If you want to analyze
such a condition, add an explicit objective constraint to your model
instead.

<br><i>(default = -1e+075)</i>

<h4><a name="CPLEXcutpass">
cutpass</a>
<i> (integer)</i> maximum number of cutting plane passes</h4><p>

Sets the upper limit on the number of passes that will be performed
when generating cutting planes on a mixed integer model.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>None</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatically determined</td></tr>
<tr valign="top"><td width=20 align=right>>0</td><td>Maximum passes to perform</td></tr>
</table>

<h4><a name="CPLEXcuts">
cuts</a>
<i> (string)</i> default cut generation</h4><p>

Allows generation setting of all optional cuts at once. This is done
by changing the meaning of the default value (0: automatic) for the
various Cplex cut generation options. The options affected are
<a href="#CPLEXcliques">cliques</a>, <a href="#CPLEXcovers">covers</a>,
<a href="#CPLEXdisjcuts">disjcuts</a>, <a href="#CPLEXflowcovers">flowcovers</a>,
<a href="#CPLEXflowpaths">flowpaths</a>, <a href="#CPLEXfraccuts">fraccuts</a>,
<a href="#CPLEXgubcovers">gubcovers</a>, <a href="#CPLEXimplbd">implbd</a>,
<a href="#CPLEXmcfcuts">mcfcuts</a>, <a href="#CPLEXmircuts">mircuts</a>,
and <a href="#CPLEXsymmetry">symmetry</a>.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate cuts aggressively</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Generate cuts very aggressively</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Generate cuts highly aggressively</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Generate cuts extremely aggressively</td></tr>
</table>

<h4><a name="CPLEXcutsfactor">
cutsfactor</a>
<i> (real)</i> cut limit</h4><p>

This option limits the number of cuts that can be added. The number of
rows in the problem with cuts added is limited to <i>cutsfactor</i> times the
original (after presolve) number of rows.

<br><i>(default = 4)</i>

<h4><a name="CPLEXcutup">
cutup</a>
<i> (real)</i> upper cutoff for tree search</h4><p>

Sets the upper cutoff tolerance. When the problem is a minimization
problem, CPLEX cuts off or discards any solutions that are greater
than the specified upper cutoff value. If the model has no solution
with an objective value less than or equal to the cutoff value, CPLEX
declares the model infeasible. In other words, setting an upper cutoff
value c for a minimization problem is similar to adding this
constraint to the objective function of the model: <tt>obj<=c</tt>.
<p>
This option overrides the GAMS Cutoff setting.
<p>
This parameter is not effective with FeasOpt. FeasOpt cannot analyze
an infeasibility introduced by this parameter. If you want to analyze
such a condition, add an explicit objective constraint to your model
instead.

<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXdepind">
depind</a>
<i> (integer)</i> dependency checker on/off</h4><p>

This option determines if and when the dependency checker will be used.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Turn off dependency checking</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Turn on only at the beginning of preprocessing</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Turn on only at the end of preprocessing</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Turn on at the beginning and at the end of preprocessing</td></tr>
</table>

<h4><a name="CPLEXdettilim">
dettilim</a>
<i> (real)</i> deterministic time limit</h4><p>

Sets a time limit expressed in ticks, a unit to measure work done
deterministically.
<p>
The length of a deterministic tick may vary by platform. Nevertheless,
ticks are normally consistent measures for a given platform
(combination of hardware and software) carrying the same load. In
other words, the correspondence of ticks to clock time depends on the
hardware, software, and the current load of the machine. For the same
platform and same load, the ratio of ticks per second stays roughly
constant, independent of the model solved. However, for very short
optimization runs, the variation of this ratio is typically high.

<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXdisjcuts">
disjcuts</a>
<i> (integer)</i> disjunctive cuts generation</h4><p>

Determines whether or not to generate disjunctive cuts during
optimization. At the default of 0, generation is continued only if it
seems to be helping.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate disjunctive cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate disjunctive cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate disjunctive cuts aggressively</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Generate disjunctive cuts very aggressively</td></tr>
</table>

<h4><a name="CPLEXdivetype">
divetype</a>
<i> (integer)</i> MIP dive strategy</h4><p>

The MIP traversal strategy occasionally performs probing dives, where
it looks ahead at both children nodes before deciding which node to
choose. The default (automatic) setting chooses when to perform a
probing dive, and the other two settings direct Cplex when to perform
probing dives: never or always.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Traditional dive</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Probing dive</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Guided dive</td></tr>
</table>

<h4><a name="CPLEX.divflt">
.divflt</a>
<i> (real <a href="#dotopt">dot option</a>)</i> solution pool range filter coefficients</h4><p>

A diversity filter for a solution pool (see option <a
href="#CPLEXsolnpool">solnpool</a>) allows you generate solutions that are
similar to (or different from) a set of reference values that you
specify for a set of binary variables. In particular, you can use a
diversity filter to generate more solutions that are similar to an
existing solution or to an existing partial solution.
<p>
A diversity filter drives the search for multiple solutions toward new
solutions that satisfy a measure of diversity specified in the filter.
This diversity measure applies only to binary variables. Potential new
solutions are compared to a reference set. This reference set is
specified with this dot option. If no reference set is specified, the
difference measure will be computed relative to the other solutions in
the pool. The diversity measure is computed by summing the pair-wise
absolute differences from solution and the reference values.

<br><i>(default = 0)</i>

<h4><a name="CPLEXdivfltlo">
divfltlo</a>
<i> (real)</i> lower bound on diversity</h4><p>

Please check option <a href="#CPLEX.divflt">.divflt</a> for general
information on a diversity filter.
<p>
If you specify a lower bound on the diversity using <i>divfltlo</i>,
Cplex will look for solutions that are different from the reference
values. In other words, you can say, Give me solutions that differ by
at least this amount in this set of variables.

<br><i>(default = mindouble)</i>

<h4><a name="CPLEXdivfltup">
divfltup</a>
<i> (real)</i> upper bound on diversity</h4><p>

Please check option <a href="#CPLEX.divflt">.divflt</a> for general
information on a diversity filter.
<p>
If you specify an upper bound on diversity <i>divfltup</i>, Cplex will
look for solutions similar to the reference values. In other words,
you can say, Give me solutions that are close to this one, within this
set of variables.

<br><i>(default = maxdouble)</i>

<h4><a name="CPLEXdpriind">
dpriind</a>
<i> (integer)</i> dual simplex pricing</h4><p>

Pricing strategy for dual simplex method. Consider using dual
steepest-edge pricing. Dual steepest-edge is particularly efficient
and does not carry as much computational burden as the primal
steepest-edge pricing.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Standard dual pricing</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Steepest-edge pricing</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Steepest-edge pricing in slack space</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Steepest-edge pricing, unit initial norms</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Devex pricing</td></tr>
</table>

<h4><a name="CPLEXeachcutlim">
eachcutlim</a>
<i> (integer)</i> Sets a limit for each type of cut</h4><p>

This parameter allows you to set a uniform limit on the number of cuts
of each type that Cplex generates. By default, the limit is a large
integer; that is, there is no effective limit by default.
<p>
Tighter limits on the number of cuts of each type may benefit certain
models. For example, a limit on each type of cut will prevent any one
type of cut from being created in such large number that the limit on
the total number of all types of cuts is reached before other types of
cuts have an opportunity to be created. A setting of 0 means no cuts.
<p>
This parameter does not influence the number of Gomory cuts. For means
to control the number of Gomory cuts, see also the fractional cut
parameters: <a href="#CPLEXfraccand">fraccand</a>, <a href="#CPLEXfraccuts">fraccuts</a>,
and <a href="#CPLEXfracpass">fracpass</a>.

<br><i>(default = 2100000000)</i>

<h4><a name="CPLEXepagap">
epagap</a>
<i> (real)</i> absolute stopping tolerance<br>&nbsp;&nbsp;&nbsp;Synonym:
optca</h4><p>

Absolute tolerance on the gap between the best integer objective and
the objective of the best node remaining.  When the value falls below
the value of the <i>epagap</i> setting, the optimization is stopped. This
option overrides GAMS OptCA which provides its
initial value.

<br><i>(default = GAMS OptCA)</i>

<h4><a name="CPLEXepgap">
epgap</a>
<i> (real)</i> relative stopping tolerance<br>&nbsp;&nbsp;&nbsp;Synonym:
optcr</h4><p>

Relative tolerance on the gap between the best integer objective and
the objective of the best node remaining.  When the value falls below
the value of the <i>epgap</i> setting, the mixed integer optimization is
stopped. Note the difference in the Cplex definition of the relative
tolerance with the GAMS definition. This option overrides GAMS
OptCR which provides its initial value.

<br><i>Range: [0,1]</i>

<br><i>(default = GAMS OptCR)</i>

<h4><a name="CPLEXepint">
epint</a>
<i> (real)</i> integrality tolerance</h4><p>

Integrality Tolerance. This specifies the amount by which an integer
variable can be different than an integer and still be considered
feasible.

<br><i>Range: [0,0.5]</i>

<br><i>(default = 1e-005)</i>

<h4><a name="CPLEXepmrk">
epmrk</a>
<i> (real)</i> Markowitz pivot tolerance</h4><p>

The Markowitz tolerance influences pivot selection during basis
factorization. Increasing the Markowitz threshold may improve the
numerical properties of the solution.

<br><i>Range: [0.0001,0.99999]</i>

<br><i>(default = 0.01)</i>

<h4><a name="CPLEXepopt">
epopt</a>
<i> (real)</i> optimality tolerance</h4><p>

The optimality tolerance influences the reduced-cost tolerance for
optimality. This option setting governs how closely Cplex must
approach the theoretically optimal solution.

<br><i>Range: [1e-009,0.1]</i>

<br><i>(default = 1e-006)</i>

<h4><a name="CPLEXepper">
epper</a>
<i> (real)</i> perturbation constant</h4><p>

Perturbation setting. Highly degenerate problems tend to stall
optimization progress. Cplex automatically perturbs the variable
bounds when this occurs. Perturbation expands the bounds on every
variable by a small amount thereby creating a different but closely
related problem. Generally, the solution to the less constrained
problem is easier to solve. Once the solution to the perturbed problem
has advanced as far as it can go, Cplex removes the perturbation by
resetting the bounds to their original values.
<p>
If the problem is perturbed more than once, the perturbation constant
is probably too large. Reduce the <i>epper</i> option to a level where
only one perturbation is required. Any value greater than or equal to
1.0e-8 is valid.

<br><i>(default = 1e-006)</i>

<h4><a name="CPLEXeprhs">
eprhs</a>
<i> (real)</i> feasibility tolerance</h4><p>

Feasibility tolerance. This specifies the degree to which a problem's
basic variables may violate their bounds.  This tolerance influences
the selection of an optimal basis and can be reset to a higher value
when a problem is having difficulty maintaining feasibility during
optimization. You may also wish to lower this tolerance after finding
an optimal solution if there is any doubt that the solution is truly
optimal. If the feasibility tolerance is set too low, Cplex may
falsely conclude that a problem is infeasible.

<br><i>Range: [1e-009,0.1]</i>

<br><i>(default = 1e-006)</i>

<h4><a name="CPLEXfeasopt">
feasopt</a>
<i> (integer)</i> computes a minimum-cost relaxation to make an infeasible model feasible</h4><p>

With <i>Feasopt</i> turned on, a minimum-cost relaxation of the right hand
side values of constraints or bounds on variables is computed in order
to make an infeasible model feasible. It marks the relaxed right hand
side values and bounds in the solution listing.
<p>
Several options are available for the metric used to determine what
constitutes a minimum-cost relaxation which can be set by option
<a href="#CPLEXfeasoptmode">feasoptmode</a>.
<p>
Feasible relaxations are available for all problem types with the
exception of quadratically constraint problems.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Turns Feasible Relaxation off</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Turns Feasible Relaxation on</td></tr>
</table>

<h4><a name="CPLEXfeasoptmode">
feasoptmode</a>
<i> (integer)</i> Mode of FeasOpt</h4><p>

The parameter <i>FeasOptMode</i> allows different strategies in finding
feasible relaxation in one or two phases. In its first phase, it
attempts to minimize its relaxation of the infeasible model. That is,
it attempts to find a feasible solution that requires minimal
change. In its second phase, it finds an optimal solution (using the
original objective) among those that require only as much relaxation
as it found necessary in the first phase.  Values of the parameter
<i>FeasOptMode</i> indicate two aspects: (1) whether to stop in phase one or
continue to phase two and (2) how to measure the minimality of the
relaxation (as a <i>sum</i> of required relaxations; as the
<i>number</i> of constraints and bounds required to be relaxed; as a
<i>sum of the squares</i> of required relaxations).

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Minimize sum of relaxations.
Minimize the sum of all required relaxations in first phase only</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Minimize sum of relaxations and optimize.
Minimize the sum of all required relaxations in first phase and
execute second phase to find optimum among minimal relaxations</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Minimize number of relaxations.
Minimize the number of constraints and bounds requiring relaxation in
first phase only</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Minimize number of relaxations and optimize.
Minimize the number of constraints and bounds requiring relaxation in
first phase and execute second phase to find optimum among minimal
relaxations</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Minimize sum of squares of relaxations.
Minimize the sum of squares of required relaxations in first phase
only</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Minimize sum of squares of relaxations and optimize.
Minimize the sum of squares of required relaxations in first phase and
execute second phase to find optimum among minimal relaxations</td></tr>
</table>

<h4><a name="CPLEX.feaspref">
.feaspref</a>
<i> (real <a href="#dotopt">dot option</a>)</i> feasibility preference</h4><p>

You can express the costs associated with relaxing a bound or
right hand side value during a <a href="#CPLEXfeasopt"><tt>feasopt</tt></a> run
through the <tt>.feaspref</tt> option. The input value denotes the
users willingness to relax a constraint or bound. More precisely, the
reciprocal of the specified value is used to weight the relaxation of
that constraint or bound. The user may specify a preference value less
than or equal to 0 (zero), which denotes that the corresponding
constraint or bound must not be relaxed.

<br><i>(default = 1)</i>

<h4><a name="CPLEXflowcovers">
flowcovers</a>
<i> (integer)</i> flow cover cut generation</h4><p>

Determines whether or not flow cover cuts should be generated during
optimization.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate flow cover cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate flow cover cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate flow cover cuts aggressively</td></tr>
</table>

<h4><a name="CPLEXflowpaths">
flowpaths</a>
<i> (integer)</i> flow path cut generation</h4><p>

Determines whether or not flow path cuts should be generated during
optimization. At the default of 0, generation is continued only if it
seems to be helping.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate flow path cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate flow path cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate flow path cuts aggressively</td></tr>
</table>

<h4><a name="CPLEXfpheur">
fpheur</a>
<i> (integer)</i> feasibility pump heuristic</h4><p>

Controls the use of the feasibility pump heuristic for mixed integer
programming (MIP) models.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Turns Feasible Pump heuristic off</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Apply the feasibility pump heuristic with an emphasis on finding a feasible solution</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Apply the feasibility pump heuristic with an emphasis on finding a feasible solution with a good objective value</td></tr>
</table>

<h4><a name="CPLEXfraccand">
fraccand</a>
<i> (integer)</i> candidate limit for generating Gomory fractional cuts</h4><p>

Limits the number of candidate variables for generating Gomory
fractional cuts.

<br><i>(default = 200)</i>

<h4><a name="CPLEXfraccuts">
fraccuts</a>
<i> (integer)</i> Gomory fractional cut generation</h4><p>

Determines whether or not Gomory fractional cuts should be generated
during optimization.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate Gomory fractional cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate Gomory fractional cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate Gomory fractional cuts aggressively</td></tr>
</table>

<h4><a name="CPLEXfracpass">
fracpass</a>
<i> (integer)</i> maximum number of passes for generating Gomory fractional cuts</h4><p>

Sets the upper limit on the number of passes that will be performed
when generating Gomory fractional cuts on a mixed integer
model. Ignored if parameter <a href="#CPLEXfraccuts">fraccuts</a> is set to a
nonzero value.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>0 Automatically determined</td></tr>
<tr valign="top"><td width=20 align=right>>0</td><td>Maximum passes to perform</td></tr>
</table>

<h4><a name="CPLEXgubcovers">
gubcovers</a>
<i> (integer)</i> GUB cover cut generation</h4><p>

Determines whether or not GUB (Generalized Upper Bound) cover cuts
should be generated during optimization.  The default of 0 indicates
that the attempt to generate GUB cuts should continue only if it seems
to be helping.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate GUB cover cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate GUB cover cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate GUB cover cuts aggressively</td></tr>
</table>

<h4><a name="CPLEXheurfreq">
heurfreq</a>
<i> (integer)</i> heuristic frequency</h4><p>

This option specifies how often to apply the node heuristic. Setting
to a positive number applies the heuristic at the requested node
interval.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not use the node heuristic</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
</table>

<h4><a name="CPLEXiis">
iis</a>
<i> (integer)</i> run the IIS finder if the problem is infeasible</h4><p>

Find an IIS (Irreducably Inconsistent Set of constraints) and write an
IIS report to the GAMS solution listing if the model is found to be
infeasible. IIS is available for LP problems only.

<br><i>(default = 0)</i>

<h4><a name="CPLEXimplbd">
implbd</a>
<i> (integer)</i> implied bound cut generation</h4><p>

Determines whether or not implied bound cuts should be generated
during optimization.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate implied bound cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate implied bound cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate implied bound cuts aggressively</td></tr>
</table>

<h4><a name="CPLEXinteractive">
interactive</a>
<i> (integer)</i> allow interactive option setting after a Control-C</h4><p>

When set to yes, options can be set interactively after interrupting
Cplex with a Control-C. Options are entered just as if they were being
entered in the <tt>cplex.opt</tt> file. Control is returned to Cplex by
entering <tt>continue</tt>. The optimization can be aborted by
entering <tt>abort</tt>. This option can only be used when running
from the command line.

<br><i>(default = 0)</i>

<h4><a name="CPLEXintsollim">
intsollim</a>
<i> (integer)</i> maximum number of integer solutions</h4><p>

This option limits the MIP optimization to finding only this number of
mixed integer solutions before stopping.

<br><i>(default = large)</i>

<h4><a name="CPLEXitlim">
itlim</a>
<i> (integer)</i> iteration limit<br>&nbsp;&nbsp;&nbsp;Synonym:
iterlim</h4><p>

The iteration limit option sets the maximum number of iterations
before the algorithm terminates, without reaching optimality. This
Cplex option overrides the GAMS IterLim option. Any non-negative
integer value is valid.

<br><i>(default = GAMS IterLim)</i>

<h4><a name="CPLEXlbheur">
lbheur</a>
<i> (integer)</i> local branching heuristic</h4><p>

This parameter lets you control whether Cplex applies a local
branching heuristic to try to improve new incumbents found during a
MIP search. By default, this parameter is off. If you turn it on,
Cplex will invoke a local branching heuristic only when it finds a new
incumbent. If Cplex finds multiple incumbents at a single node, the
local branching heuristic will be applied only to the last one found.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Off</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Apply local branching heuristic to new incumbent</td></tr>
</table>

<h4><a name="CPLEXlpmethod">
lpmethod</a>
<i> (integer)</i> algorithm to be used for LP problems</h4><p>

Specifies which LP algorithm to use. If left at the default value (0
for automatic), and a primal-feasible basis is available, primal
simplex will be used. If no primal-feasible basis is available, and
<a href="#CPLEXthreads">threads</a> is equal to 1, dual simplex will be used. If
<a href="#CPLEXthreads">threads</a> is greater than 1 and no primal-feasible
basis is available, the concurrent option will be used.
<p>
Sifting may be useful for problems with many more variables than
equations.
<p>
The concurrent option runs multiple methods in parallel. The first
thread uses dual simplex. The second thread uses barrier. The next
thread uses primal simplex. Remaining threads are used by the barrier
run. The solution is returned by first method to finish.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Primal Simplex</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Dual Simplex</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Network Simplex</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Barrier</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Sifting</td></tr>
<tr valign="top"><td width=20 align=right>6</td><td>Concurrent</td></tr>
</table>

<h4><a name="CPLEXmcfcuts">
mcfcuts</a>
<i> (integer)</i> multi-commodity flow cut generation</h4><p>

Specifies whether Cplex should generate multi-commodity flow (MCF)
cuts in a problem where Cplex detects the characteristics of a
multi-commodity flow network with arc capacities. By default, Cplex
decides whether or not to generate such cuts.  To turn off generation
of such cuts, set this parameter to -1.  Cplex is able to recognize
the structure of a network as represented in many real-world
models. When it recognizes such a network structure, Cplex is able to
generate cutting planes that usually help solve such problems. In this
case, the cuts that Cplex generates state that the capacities
installed on arcs pointing into a component of the network must be at
least as large as the total flow demand of the component that cannot
be satisfied by flow sources within the component.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate MCF cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate MCF cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate MCF cuts aggressively</td></tr>
</table>

<h4><a name="CPLEXmemoryemphasis">
memoryemphasis</a>
<i> (integer)</i> Reduces use of memory</h4><p>

This parameter lets you indicate to Cplex that it should conserve
memory where possible. When you set this parameter to its non default
value, Cplex will choose tactics, such as data compression or disk
storage, for some of the data computed by the barrier and MIP
optimizers. Of course, conserving memory may impact performance in
some models. Also, while solution information will be available after
optimization, certain computations that require a basis that has been
factored (for example, for the computation of the condition number
Kappa) may be unavailable.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Do not conserve memory</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Conserve memory where possible</td></tr>
</table>

<h4><a name="CPLEXmipdisplay">
mipdisplay</a>
<i> (integer)</i> progress display level</h4><p>

The amount of information displayed during MIP solution increases with
increasing values of this option.

<br><i>(default = 4)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>No display</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Display integer feasible solutions</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Displays nodes under mipinterval control</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Same as 2 but adds information on cuts</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Same as 3 but adds LP display for the root node</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Same as 3 but adds LP display for all nodes</td></tr>
</table>

<h4><a name="CPLEXmipemphasis">
mipemphasis</a>
<i> (integer)</i> MIP solution tactics</h4><p>

This option controls the tactics for solving a mixed integer
programming problem.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Balance optimality and feasibility</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Emphasize feasibility over optimality</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Emphasize optimality over feasibility</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Emphasize moving the best bound</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Emphasize hidden feasible solutions</td></tr>
</table>

<h4><a name="CPLEXmipinterval">
mipinterval</a>
<i> (integer)</i> progress display interval</h4><p>

<p>
Controls the frequency of node logging when the parameter <a
href="#CPLEXmipdisplay">mipdisplay</a> is set higher than 1 (one).
Frequency must be an integer; it may be 0 (zero), positive, or
negative.  By default, CPLEX displays new information in the node log
during a MIP solve at relatively high frequency during the early
stages of solving a MIP model, and adds lines to the log at
progressively longer intervals as solving continues. In other words,
CPLEX logs information frequently in the beginning and progressively
less often as it works.  When the value is a positive integer <i>n</i>, CPLEX
displays new incumbents, plus it displays a new line in the log every
<i>n</i> nodes.  When the value is a negative integer <i>n</i>, CPLEX displays new
incumbents, and the negative value determines how much processing
CPLEX does before it displays a new line in the node log. A negative
value close to zero means that CPLEX displays new lines in the log
frequently. A negative value far from zero means that CPLEX displays
new lines in the log less frequently. In other words, a negative value
of this parameter contracts or dilates the interval at which CPLEX
displays information in the node log.

<br><i>(default = 0)</i>

<h4><a name="CPLEXmipkappastats">
mipkappastats</a>
<i> (integer)</i> MIP kappa computation</h4><p>

MIP kappa summarizes the distribution of the condition number of the
optimal bases CPLEX encountered during the solution of a MIP
model. That summary may let you know more about the numerical
difficulties of your MIP model. Because MIP kappa (as a statistical
distribution) requires CPLEX to compute the condition number of the
optimal bases of the subproblems during branch-and-cut search, you can
compute the MIP kappa only when CPLEX solves the subproblem with its
simplex optimizer. In other words, in order to obtain results with
this parameter, you can not use the sifting optimizer nor the barrier
without crossover to solve the subproblems. See the parameters
<a href="#CPLEXstartalg">startalg</a> and <a href="#CPLEXsubalg">subalg</a>.
<p>
Computing the kappa of a subproblem has a cost. In fact, computing MIP
kappa for the basis matrices can be computationally expensive and thus
generally slows down the solution of a problem. Therefore, the
setting 0 (automatic) tells CPLEX generally not to compute MIP kappa,
but in cases where the parameter <a href="#CPLEXnumericalemphasis">numericalemphasis</a>
is turned on, CPLEX computes MIP kappa for a sample of subproblems.
The value 1 (sample) leads to a negligible performance degradation on
average, but can slow down the branch-and-cut exploration by as much
as 10% on certain models.  The value 2 (full) leads to a 2%
performance degradation on average, but can significantly slow the
branch-and-cut exploration on certain models.  In practice, the value
1 (sample) is a good trade-off between performance and accuracy of
statistics.  If you need very accurate statistics, then use value 2
(full).
<p>
In case CPLEX is instructed to compute a MIP kappa distribution, the
parameter <a href="#CPLEXquality">quality</a> is automatically turned on.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>No MIP kappa statistics; default</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic: let CPLEX decide</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Compute MIP kappa for a sample of subproblems</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Compute MIP kappa for all subproblems</td></tr>
</table>

<h4><a name="CPLEXmipordind">
mipordind</a>
<i> (integer)</i> priority list on/off<br>&nbsp;&nbsp;&nbsp;Synonym:
prioropt</h4><p>

Use priorities. Priorities should be assigned based on your knowledge
of the problem. Variables with higher priorities will be branched upon
before variables of lower priorities. This direction of the tree
search can often dramatically reduce the number of nodes searched. For
example, consider a problem with a binary variable representing a
yes/no decision to build a factory, and other binary variables
representing equipment selections within that factory. You would
naturally want to explore whether or not the factory should be built
before considering what specific equipment to purchased within the
factory. By assigning a higher priority to the build/no build decision
variable, you can force this logic into the tree search and eliminate
wasted computation time exploring uninteresting portions of the
tree. When set at 0 (default), the <i>mipordind</i> option instructs
Cplex not to use priorities for branching. When set to 1, priority
orders are utilized.
<p>
Note: Priorities are assigned to discrete variables using the .prior
suffix in the GAMS model. Lower .prior values mean higher
priority. The <tt>.prioropt</tt> model suffix has to be used to signal GAMS to
export the priorities to the solver.

<br><i>(default = GAMS PriorOpt)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Do not use priorities for branching</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Priority orders are utilized</td></tr>
</table>

<h4><a name="CPLEXmipordtype">
mipordtype</a>
<i> (integer)</i> priority order generation</h4><p>

This option is used to select the type of generic priority order to
generate when no priority order is present.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>None</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>decreasing cost magnitude</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>increasing bound range</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>increasing cost per coefficient count</td></tr>
</table>

<h4><a name="CPLEXmipsearch">
mipsearch</a>
<i> (integer)</i> search strategy for mixed integer programs</h4><p>

Sets the search strategy for a mixed integer program. By default,
Cplex chooses whether to apply dynamic search or conventional branch
and cut based on characteristics of the model.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Apply traditional branch and cut strategy</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Apply dynamic search</td></tr>
</table>

<h4><a name="CPLEXmipstart">
mipstart</a>
<i> (integer)</i> use mip starting values</h4><p>

This option controls the use of advanced starting values for mixed
integer programs. A setting of 1 indicates that the values should be
checked to see if they provide an integer feasible solution before
starting optimization.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>do not use the values</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>use the values</td></tr>
</table>

<h4><a name="CPLEXmiqcpstrat">
miqcpstrat</a>
<i> (integer)</i> MIQCP relaxation choice</h4><p>

This option controls how MIQCPs are solved. For some models, the
setting 2 may be more effective than 1. You may need to experiment
with this parameter to determine the best setting for your model.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>QCP relaxation.
Cplex will solve a QCP relaxation of the model at each node.</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>LP relaxation.
Cplex will solve a LP relaxation of the model at each node.</td></tr>
</table>

<h4><a name="CPLEXmircuts">
mircuts</a>
<i> (integer)</i> mixed integer rounding cut generation</h4><p>

Determines whether or not to generate mixed integer rounding (MIR)
cuts during optimization. At the default of 0, generation is continued
only if it seems to be helping.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Do not generate MIR cuts</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate MIR cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate MIR cuts aggressively</td></tr>
</table>

<h4><a name="CPLEXmpslongnum">
mpslongnum</a>
<i> (integer)</i> MPS file format precision of numeric output</h4><p>

Determines the precision of numeric output in the MPS file
formats. When this parameter is set to its default value 1 (one),
numbers are written to MPS files in full-precision; that is, up to 15
significant digits may be written. The setting 0 (zero) writes files
that correspond to the standard MPS format, where at most 12
characters can be used to represent a value. This limit may result in
loss of precision.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Use limited MPS precision</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Use full-precision</td></tr>
</table>

<h4><a name="CPLEXnames">
names</a>
<i> (integer)</i> load GAMS names into Cplex</h4><p>

This option causes GAMS names for the variables and equations to be
loaded into Cplex. These names will then be used for error messages,
log entries, and so forth. Setting names to no may help if memory is
very tight.

<br><i>(default = 1)</i>

<h4><a name="CPLEXnetdisplay">
netdisplay</a>
<i> (integer)</i> network display level</h4><p>

This option controls the log for network iterations.

<br><i>(default = 2)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>No network log.</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Displays true objective values</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Displays penalized objective values</td></tr>
</table>

<h4><a name="CPLEXnetepopt">
netepopt</a>
<i> (real)</i> optimality tolerance for the network simplex method</h4><p>

This optimality tolerance influences the reduced-cost tolerance for
optimality when using the network simplex method. This option setting
governs how closely Cplex must approach the theoretically optimal
solution.

<br><i>Range: [1e-011,0.1]</i>

<br><i>(default = 1e-006)</i>

<h4><a name="CPLEXneteprhs">
neteprhs</a>
<i> (real)</i> feasibility tolerance for the network simplex method</h4><p>

This feasibility tolerance determines the degree to which the network
simplex algorithm will allow a flow value to violate its bounds.

<br><i>Range: [1e-011,0.1]</i>

<br><i>(default = 1e-006)</i>

<h4><a name="CPLEXnetfind">
netfind</a>
<i> (integer)</i> attempt network extraction</h4><p>

Specifies the level of network extraction to be done.

<br><i>(default = 2)</i>
<table>
<tr valign="top"><td width=20 align=right>1</td><td>Extract pure network only</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Try reflection scaling</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Try general scaling</td></tr>
</table>

<h4><a name="CPLEXnetitlim">
netitlim</a>
<i> (integer)</i> iteration limit for network simplex</h4><p>

Iteration limit for the network simplex method.

<br><i>(default = large)</i>

<h4><a name="CPLEXnetppriind">
netppriind</a>
<i> (integer)</i> network simplex pricing</h4><p>

Network simplex pricing algorithm. The default of 0 (currently
equivalent to 3) shows best performance for most problems.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Partial pricing</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Multiple partial pricing</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Multiple partial pricing with sorting</td></tr>
</table>

<h4><a name="CPLEXnodefileind">
nodefileind</a>
<i> (integer)</i> node storage file indicator</h4><p>

Specifies how node files are handled during MIP processing. Used when
parameter <a href="#CPLEXworkmem">workmem</a> has been exceeded by the size of
the branch and cut tree. If set to 0 when the tree memory limit is
reached, optimization is terminated. Otherwise a group of nodes is
removed from the in-memory set as needed. By default, Cplex transfers
nodes to node files when the in-memory set is larger than 128 MBytes,
and it keeps the resulting node <i>files</i> in compressed form in
memory. At settings 2 and 3, the node files are transferred to
disk. They are stored under a directory specified by parameter
<a href="#CPLEXworkdir">workdir</a> and Cplex actively manages which nodes remain
in memory for processing.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>No node files</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Node files in memory and compressed</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Node files on disk</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Node files on disk and compressed</td></tr>
</table>

<h4><a name="CPLEXnodelim">
nodelim</a>
<i> (integer)</i> maximum number of nodes to solve<br>&nbsp;&nbsp;&nbsp;Synonym:
nodlim</h4><p>

The maximum number of nodes solved before the algorithm terminates,
without reaching optimality. This option overrides the GAMS NodLim
model suffix. When this parameter is set to 0 (this is only possible
through an option file), Cplex completes processing at the root; that
is, it creates cuts and applies heuristics at the root. When this
parameter is set to 1 (one), it allows branching from the root; that
is, nodes are created but not solved.

<br><i>(default = GAMS NodLim)</i>

<h4><a name="CPLEXnodesel">
nodesel</a>
<i> (integer)</i> node selection strategy</h4><p>

This option is used to set the rule for selecting the next node to
process when backtracking.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Depth-first search.
This chooses the most recently created node.</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Best-bound search.
This chooses the unprocessed node with the best objective function for
the associated LP relaxation.</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Best-estimate search.
This chooses the node with the best estimate of the integer objective
value that would be obtained once all integer infeasibilities are
removed.</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Alternate best-estimate search</td></tr>
</table>

<h4><a name="CPLEXnumericalemphasis">
numericalemphasis</a>
<i> (integer)</i> emphasizes precision in numerically unstable or difficult problems</h4><p>

This parameter lets you indicate to Cplex that it should emphasize
precision in numerically difficult or unstable problems, with
consequent performance trade-offs in time and memory.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Off</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Exercise extreme caution in computation</td></tr>
</table>

<h4><a name="CPLEXobjdif">
objdif</a>
<i> (real)</i> overrides GAMS Cheat parameter<br>&nbsp;&nbsp;&nbsp;Synonym:
cheat</h4><p>

A means for automatically updating the cutoff to more restrictive
values. Normally the most recently found integer feasible solution
objective value is used as the cutoff for subsequent nodes. When this
option is set to a positive value, the value will be subtracted from
(added to) the newly found integer objective value when minimizing
(maximizing). This forces the MIP optimization to ignore integer
solutions that are not at least this amount better than the one found
so far. The option can be adjusted to improve problem solving
efficiency by limiting the number of nodes; however, setting this
option at a value other than zero (the default) can cause some integer
solutions, including the true integer optimum, to be missed.  Negative
values for this option will result in some integer solutions that are
worse than or the same as those previously generated, but will not
necessarily result in the generation of all possible integer
solutions. This option overrides the GAMS Cheat parameter.

<br><i>(default = 0)</i>

<h4><a name="CPLEXobjllim">
objllim</a>
<i> (real)</i> objective function lower limit</h4><p>

Setting a lower objective function limit will cause Cplex to halt the
optimization process once the minimum objective function value limit
has been exceeded.

<br><i>(default = -1e+075)</i>

<h4><a name="CPLEXobjrng">
objrng</a>
<i> (string)</i> do objective ranging</h4><p>

Calculate sensitivity ranges for the specified GAMS variables. Unlike
most options, <i>objrng</i> can be repeated multiple times in the options
file. Sensitivity range information will be produced for each GAMS
variable named. Specifying <tt>all</tt> will cause range information
to be produced for all variables. Range information will be printed to
the beginning of the solution listing in the GAMS listing file unless
option <a href="#CPLEXrngrestart">rngrestart</a> is specified.

<br><i>(default = no objective ranging is done)</i>

<h4><a name="CPLEXobjulim">
objulim</a>
<i> (real)</i> objective function upper limit</h4><p>

Setting an upper objective function limit will cause Cplex to halt the
optimization process once the maximum objective function value limit
has been exceeded.

<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXparallelmode">
parallelmode</a>
<i> (integer)</i> parallel optimization mode</h4><p>

Sets the parallel optimization mode. Possible modes are automatic,
deterministic, and opportunistic.
<p>
In this context, deterministic means that multiple runs with the same
model at the same parameter settings on the same platform will
reproduce the same solution path and results. In contrast,
opportunistic implies that even slight differences in timing among
threads or in the order in which tasks are executed in different
threads may produce a different solution path and consequently
different timings or different solution vectors during optimization
executed in parallel threads. When running with multiple threads, the
opportunistic setting entails less synchronization between threads and
consequently may provide better performance.
<p>
In deterministic mode, Cplex applies as much parallelism as possible
while still achieving deterministic results. That is, when you run the
same model twice on the same platform with the same parameter
settings, you will see the same solution and optimization run.
<p>
More opportunities to exploit parallelism are available if you do not
require determinism. In other words, Cplex can find more opportunities
for parallelism if you do not require an invariant, repeatable
solution path and precisely the same solution vector. To use all
available parallelism, you need to select the opportunistic parallel
mode. In this mode, Cplex will utilize all opportunities for
parallelism in order to achieve best performance.
<p>
However, in opportunistic mode, the actual optimization may differ
from run to run, including the solution time itself. A truly parallel
deterministic algorithm is available only for MIP optimization.  Only
opportunistic parallel algorithms (barrier and concurrent optimizers)
are available for continuous models. (Each of the simplex algorithms
runs sequentially on a continuous model.) Consequently, when parallel
mode is set to deterministic, both barrier and concurrent optimizers
are restricted to run only sequentially, not in parallel.
<p>
A GAMS/Cplex run will use deterministic mode unless explicitely specified.
<p>
If <i>parallelmode</i> is explicitely set to 0 (automatic) the settings
of this parallel mode parameter interact with settings of the
<a href="#CPLEXthreads">threads</a> parameter. Let the result number of
threads available to Cplex be <i>n</i> (note that negative values for
the threads parameter are possible to exclude work on some cores).
<p>
<i>n</i>=0: Cplex uses maximum number of threads (determined by the
computing platform) in deterministic mode unless <i>parallelmode</i>
is set to -1 (opportunistic).
<p>
<i>n</i>=1: Cplex runs sequential.
<p>
<i>n</i>&gt;1: Cplex uses maximum number of threads (determined by the
computing platform) in opportunistic mode unless <i>parallelmode</i>
is set to 1 (deterministic).
<p>
Here is is list of possible value:

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Enable opportunistic parallel search mode</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Enable deterministic parallel search mode</td></tr>
</table>

<h4><a name="CPLEXperind">
perind</a>
<i> (integer)</i> force initial perturbation</h4><p>

Perturbation Indicator. If a problem automatically perturbs early in
the solution process, consider starting the solution process with a
perturbation by setting <i>perind</i> to 1. Manually perturbing the problem
will save the time of first allowing the optimization to stall before
activating the perturbation mechanism, but is useful only rarely, for
extremely degenerate problems.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>not automatically perturbed</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>automatically perturbed</td></tr>
</table>

<h4><a name="CPLEXperlim">
perlim</a>
<i> (integer)</i> number of stalled iterations before perturbation</h4><p>

Perturbation limit. The number of stalled iterations before
perturbation is invoked. The default value of 0 means the number is
determined automatically.

<br><i>(default = 0)</i>

<h4><a name="CPLEXpolishafterdettime">
polishafterdettime</a>
<i> (real)</i> Deterministic time before starting to polish a feasible solution</h4><p>


<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXpolishafterepagap">
polishafterepagap</a>
<i> (real)</i> Absolute MIP gap before starting to polish a feasible solution</h4><p>

Solution polishing can yield better solutions in situations where good
solutions are otherwise hard to find. More time-intensive than other
heuristics, solution polishing is actually a variety of branch-and-cut
that works after an initial solution is available. In fact, it
requires a solution to be available for polishing, either a solution
produced by branch-and-cut, or a MIP start supplied by a user.
Because of the high cost entailed by solution polishing, it is not
called throughout branch-and-cut like other heuristics. Instead,
solution polishing works in a second phase after a first phase of
conventional branch-and-cut. As an additional step after
branch-and-cut, solution polishing can improve the best known
solution.  As a kind of branch-and-cut algorithm itself, solution
polishing focuses solely on finding better solutions. Consequently, it
may not prove optimality, even if the optimal solution has indeed been
found. Like the RINS heuristic, solution polishing explores
neighborhoods of previously found solutions by solving subMIPs.
<p>
Sets an absolute MIP gap (that is, the difference between the best
integer objective and the objective of the best node remaining) after
which CPLEX stops branch-and-cut and begins polishing a feasible
solution. The default value is such that CPLEX does not invoke
solution polishing by default.

<br><i>(default = 0)</i>

<h4><a name="CPLEXpolishafterepgap">
polishafterepgap</a>
<i> (real)</i> Relative MIP gap before starting to polish a solution</h4><p>

Sets a relative MIP gap after which CPLEX will stop branch-and-cut and
begin polishing a feasible solution. The default value is such that
CPLEX does not invoke solution polishing by default.

<br><i>(default = 0)</i>

<h4><a name="CPLEXpolishafterintsol">
polishafterintsol</a>
<i> (integer)</i> MIP integer solutions to find before starting to polish a feasible solution</h4><p>

Sets the number of integer solutions to find before CPLEX stops
branch-and-cut and begins to polish a feasible solution. The default
value is such that CPLEX does not invoke solution polishing by
default.

<br><i>(default = 2100000000)</i>

<h4><a name="CPLEXpolishafternode">
polishafternode</a>
<i> (integer)</i> Nodes to process before starting to polish a feasible solution</h4><p>

Sets the number of nodes processed in branch-and-cut before CPLEX
starts solution polishing, if a feasible solution is available.

<br><i>(default = 2100000000)</i>

<h4><a name="CPLEXpolishaftertime">
polishaftertime</a>
<i> (real)</i> Time before starting to polish a feasible solution</h4><p>

Tells CPLEX how much time in seconds to spend during mixed integer
optimization before CPLEX starts polishing a feasible solution. The
default value is such that CPLEX does not start solution polishing by
default.

<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXpopulatelim">
populatelim</a>
<i> (integer)</i> limit of solutions generated for the solution pool by populate method</h4><p>

Limits the number of solutions generated for the solution pool during
each call to the populate procedure. Populate stops when it has
generated <i>PopulateLim</i> solutions. A solution is counted if it is
valid for all filters (see <a href="#CPLEX.divflt">.divflt</a> and
consistent with the relative and absolute pool gap parameters (see <a
href="#CPLEXsolnpoolgap">solnpoolgap</a> and <a
href="#CPLEXsolnpoolagap">solnpoolagap</a>), and has not been rejected by
the incumbent checking routine (see <a
href="#CPLEXuserincbcall">userincbcall</a>), whether or not it improves the
objective of the model. This parameter does not apply to MIP
optimization generally; it applies only to the populate procedure.
<p>
If you are looking for a parameter to control the number of solutions
stored in the solution pool, consider the parameter <a
href="#CPLEXsolnpoolcapacity">solnpoolcapacity</a> instead.
<p>
Populate will stop before it reaches the limit set by this parameter
if it reaches another limit, such as a time or node limit set by the
user.

<br><i>(default = 20)</i>

<h4><a name="CPLEXppriind">
ppriind</a>
<i> (integer)</i> primal simplex pricing</h4><p>

Pricing algorithm. Likely to show the biggest impact on
performance. Look at overall solution time and the number of Phase I
and total iterations as a guide in selecting alternate pricing
algorithms. If you are using the dual Simplex method use <i>dpriind</i> to
select a pricing algorithm. If the number of iterations required to
solve your problem is approximately the same as the number of rows in
your problem, then you are doing well. Iteration counts more than
three times greater than the number of rows suggest that improvements
might be possible.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Reduced-cost pricing.
This is less compute intensive and may be preferred if the problem is
small or easy. This option may also be advantageous for dense problems
(say 20 to 30 nonzeros per column).</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Hybrid reduced-cost and Devex pricing</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Devex pricing.
This may be useful for more difficult problems which take many
iterations to complete Phase I. Each iteration may consume more time,
but the reduced number of total iterations may lead to an overall
reduction in time. Tenfold iteration count reductions leading to
threefold speed improvements have been observed. Do not use devex
pricing if the problem has many columns and relatively few rows. The
number of calculations required per iteration will usually be
disadvantageous.</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Steepest edge pricing.
If devex pricing helps, this option may be beneficial. Steepest-edge
pricing is computationally expensive, but may produce the best results
on exceptionally difficult problems.</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Steepest edge pricing with slack initial norms.
This reduces the computationally intensive nature of steepest edge
pricing.</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Full pricing</td></tr>
</table>

<h4><a name="CPLEXpredual">
predual</a>
<i> (integer)</i> give dual problem to the optimizer</h4><p>

Solve the dual. Some linear programs with many more rows than columns
may be solved faster by explicitly solving the dual. The <i>predual</i>
option will cause Cplex to solve the dual while returning the solution
in the context of the original problem. This option is ignored if
presolve is turned off.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>do not give dual to optimizer</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>give dual to optimizer</td></tr>
</table>

<h4><a name="CPLEXpreind">
preind</a>
<i> (integer)</i> turn presolver on/off</h4><p>

Perform Presolve. This helps most problems by simplifying, reducing
and eliminating redundancies. However, if there are no redundancies or
opportunities for simplification in the model, if may be faster to
turn presolve off to avoid this step. On rare occasions, the presolved
model, although smaller, may be more difficult than the original
problem. In this case turning the presolve off leads to better
performance. Specifying 0 turns the aggregator off as well.

<br><i>(default = 1)</i>

<h4><a name="CPLEXprelinear">
prelinear</a>
<i> (integer)</i> linear reduction indicator</h4><p>

If only linear reductions are performed, each variable in the original
model can be expressed as a linear form of variables in the presolved
model.

<br><i>(default = 1)</i>

<h4><a name="CPLEXprepass">
prepass</a>
<i> (integer)</i> number of presolve applications to perform</h4><p>

Number of MIP presolve applications to perform. By default, Cplex
determines this automatically. Specifying 0 turns off the presolve but
not the aggregator. Set <a href="#CPLEXpreind">preind</a> to 0 to turn both
off.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Determined automatically</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>No presolve</td></tr>
</table>

<h4><a name="CPLEXpreslvnd">
preslvnd</a>
<i> (integer)</i> node presolve selector</h4><p>

Indicates whether node presolve should be performed at the nodes of a
mixed integer programming solution.  Node presolve can significantly
reduce solution time for some models. The default setting is generally
effective.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>No node presolve</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Force node presolve</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Perform probing on integer-infeasible variables</td></tr>
</table>

<h4><a name="CPLEXpricelim">
pricelim</a>
<i> (integer)</i> pricing candidate list</h4><p>

Size for the pricing candidate list. Cplex dynamically determines a
good value based on problem dimensions.  Only very rarely will setting
this option manually improve performance. Any non-negative integer
values are valid.

<br><i>(default = 0, in which case it is determined automatically)</i>

<h4><a name="CPLEXprintoptions">
printoptions</a>
<i> (integer)</i> list values of all options to GAMS listing file</h4><p>

Write the values of all options to the GAMS listing file. Valid values
are no or yes.

<br><i>(default = 0)</i>

<h4><a name="CPLEXprobe">
probe</a>
<i> (integer)</i> perform probing before solving a MIP</h4><p>

Determines the amount of probing performed on a MIP. Probing can be
both very powerful and very time consuming. Setting the value to 1 can
result in dramatic reductions or dramatic increases in solution time
depending on the particular model.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>No probing</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Limited probing</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>More probing</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Full probing</td></tr>
</table>

<h4><a name="CPLEXprobedettime">
probedettime</a>
<i> (real)</i> deterministic time spent probing</h4><p>


<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXprobetime">
probetime</a>
<i> (real)</i> time spent probing</h4><p>

Limits the amount of time in seconds spent probing.

<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXqpmakepsdind">
qpmakepsdind</a>
<i> (integer)</i> adjust MIQP formulation to make the quadratic matrix positive-semi-definite</h4><p>

Determines whether Cplex will attempt to adjust a MIQP formulation, in
which all the variables appearing in the quadratic term are
binary. When this feature is active, adjustments will be made to the
elements of a quadratic matrix that is not nominally positive
semi-definite (<i>PSD</i>, as required by Cplex for all QP
formulations), to make it PSD, and will also attempt to tighten an
already PSD matrix for better numerical behavior. The default setting
of 1 means <tt>yes</tt> but you can turn it off if necessary; most
models should benefit from the default setting.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Off</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>On</td></tr>
</table>

<h4><a name="CPLEXqpmethod">
qpmethod</a>
<i> (integer)</i> algorithm to be used for QP problems</h4><p>

Specifies which QP algorithm to use.
<p>
At the default of 0 (automatic), barrier is used for QP problems and
dual simplex for the root relaxation of MIQP problems.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Primal Simplex</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Dual Simplex</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Network Simplex</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Barrier</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Sifting</td></tr>
<tr valign="top"><td width=20 align=right>6</td><td>Concurrent dual, barrier, and primal</td></tr>
</table>

<h4><a name="CPLEXquality">
quality</a>
<i> (integer)</i> write solution quality statistics</h4><p>

Write solution quality statistics to the listing file. If set to yes,
the statistics appear after the Solve Summary and before the Solution
Listing.

<br><i>(default = 0)</i>

<h4><a name="CPLEXrandomseed">
randomseed</a>
<i> (integer)</i> sets the random seed differently for diversity of solutions</h4><p>


<br><i>(default = changes with each Cplex release)</i>

<h4><a name="CPLEXreadflt">
readflt</a>
<i> (string)</i> reads Cplex solution pool filter file</h4><p>

The GAMS/Cplex solution pool options cover the basic use of diversity
and range filters for producing multiple solutions. If you need
multiple filters, weights on diversity filters or other advanced uses
of solution pool filters, you could produce a Cplex filter file with
your favorite editor or the GAMS Put Facility and read this into
GAMS/Cplex using this option.


<h4><a name="CPLEXreduce">
reduce</a>
<i> (integer)</i> primal and dual reduction type</h4><p>

Determines whether primal reductions, dual reductions, or both, are
performed during preprocessing. It is occasionally advisable to do
only one or the other when diagnosing infeasible or unbounded models.

<br><i>(default = 3)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>No primal or dual reductions</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Only primal reductions</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Only dual reductions</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Both primal and dual reductions</td></tr>
</table>

<h4><a name="CPLEXreinv">
reinv</a>
<i> (integer)</i> refactorization frequency</h4><p>

Refactorization Frequency. This option determines the number of
iterations between refactorizations of the basis matrix. The default
should be optimal for most problems. Cplex's performance is relatively
insensitive to changes in refactorization frequency. Only for
extremely large, difficult problems should reducing the number of
iterations between refactorizations be considered. Any non-negative
integer value is valid.

<br><i>(default = 0, in which case it is determined automatically)</i>

<h4><a name="CPLEXrelaxfixedinfeas">
relaxfixedinfeas</a>
<i> (integer)</i> access small infeasibilties in the solve of the fixed problem</h4><p>

Sometimes the solution of the fixed problem of a MIP does not solve to
optimality due to small (dual) infeasibilities. The default behavior
of the GAMS/Cplex link is to return the primal solution values
only. If the option is set to 1, the small infeasibilities are ignored
and a full solution including the dual values are reported back to
GAMS.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Off</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>On</td></tr>
</table>

<h4><a name="CPLEXrelaxpreind">
relaxpreind</a>
<i> (integer)</i> presolve for initial relaxation on/off</h4><p>

This option will cause the Cplex presolve to be invoked for the
initial relaxation of a mixed integer program (according to the other
presolve option settings). Sometimes, additional reductions can be
made beyond any MIP presolve reductions that may already have been
done.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>do not presolve initial relaxation</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>use presolve on initial relaxation</td></tr>
</table>

<h4><a name="CPLEXrelobjdif">
relobjdif</a>
<i> (real)</i> relative cheat parameter</h4><p>

The relative version of the <a href="#CPLEXobjdif">objdif</a> option. Ignored
if objdif is non-zero.

<br><i>(default = 0)</i>

<h4><a name="CPLEXrepairtries">
repairtries</a>
<i> (integer)</i> try to repair infeasible MIP start</h4><p>

This parameter lets you indicate to Cplex whether and how many times
it should try to repair an infeasible MIP start that you supplied. The
parameter has no effect if the MIP start you supplied is feasible. It
has no effect if no MIP start was supplied.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>None: do not try to repair</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>>0</td><td>Maximum tries to perform</td></tr>
</table>

<h4><a name="CPLEXrepeatpresolve">
repeatpresolve</a>
<i> (integer)</i> reapply presolve at root after preprocessing</h4><p>

This integer parameter tells Cplex whether to re-apply presolve, with
or without cuts, to a MIP model after processing at the root is
otherwise complete.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Turn off represolve</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Represolve without cuts</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Represolve with cuts</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Represolve with cuts and allow new root cuts</td></tr>
</table>

<h4><a name="CPLEXrerun">
rerun</a>
<i> (string)</i> rerun problem if presolve infeasible or unbounded</h4><p>

The Cplex presolve can sometimes diagnose a problem as being
infeasible or unbounded. When this happens, GAMS/Cplex can, in order
to get better diagnostic information, rerun the problem with presolve
turned off.  The GAMS solution listing will then mark variables and
equations as infeasible or unbounded according to the final solution
returned by the simplex algorithm. The <a href="#CPLEXiis">iis</a> option
can be used to get even more diagnostic information. The rerun option
controls this behavior. Valid values are auto, yes, no and nono. The
value of auto is equivalent to no if names are successfully loaded
into Cplex and option <a href="#CPLEXiis">iis</a> is set to no. In that
case the Cplex messages from presolve help identify the cause of
infeasibility or unboundedness in terms of GAMS variable and equation
names. If names are not successfully loaded, rerun defaults to
yes. Loading of GAMS names into Cplex is controlled by option <a
href="#CPLEXnames">names</a>. The value of nono only affects MIP models for
which Cplex finds a feasible solution in the branch-and-bound tree but
the fixed problem turns out to be infeasible. In this case the value
nono also disables the rerun without presolve, while the value of no
still tries this run. Feasible integer solution but an infeasible
fixed problem happens in few cases and mostly with badly scaled
models. If you experience this try more aggressive scaling (<a
href="#CPLEXscaind">scaind</a>) or tightening the integer feasibility
tolerance <a href="#CPLEXepint">epint</a>. If the fixed model is infeasible
only the primal solution is returned to GAMS. You can recognize this
inside GAMS by checking the marginal of the objective defining
constraint which is always nonzero.

<br><i>(default = yes)</i>
<table>
<tr valign="top"><td width=20 align=right>auto</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>yes</td><td>Rerun infeasible models with presolve turned off</td></tr>
<tr valign="top"><td width=20 align=right>no</td><td>Do not rerun infeasible models</td></tr>
<tr valign="top"><td width=20 align=right>nono</td><td>Do not rerun infeasible fixed MIP models</td></tr>
</table>

<h4><a name="CPLEXrhsrng">
rhsrng</a>
<i> (string)</i> do right-hand-side ranging</h4><p>

Calculate sensitivity ranges for the specified GAMS equations. Unlike
most options, <i>rhsrng</i> can be repeated multiple times in the options
file. Sensitivity range information will be produced for each GAMS
equation named. Specifying <tt>all</tt> will cause range information
to be produced for all equations. Range information will be printed to
the beginning of the solution listing in the GAMS listing file unless
option <a href="#CPLEXrngrestart">rngrestart</a> is specified.

<br><i>(default = no right-hand-side ranging is done)</i>

<h4><a name="CPLEXrinsheur">
rinsheur</a>
<i> (integer)</i> relaxation induced neighborhood search frequency</h4><p>

Cplex implements a heuristic known a Relaxation Induced Neighborhood
Search (RINS) for MIP and MIQCP problems. RINS explores a neighborhood
of the current incumbent to try to find a new, improved incumbent. It
formulates the neighborhood exploration as a MIP, a subproblem known
as the subMIP, and truncates the subMIP solution by limiting the
number of nodes explored in the search tree.
<p>
Parameter <i>rinsheur</i> controls how often RINS is invoked. A value of 100,
for example, means that RINS is invoked every hundredth node in the
tree.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Disable RINS</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
</table>

<h4><a name="CPLEXrngrestart">
rngrestart</a>
<i> (string)</i> write GAMS readable ranging information file</h4><p>

Write ranging information, in GAMS readable format, to the file
named. Options <a href="#CPLEXobjrng">objrng</a> and <a href="#CPLEXrhsrng">rhsrng</a>
are used to specify which GAMS variables or equations are included.

<br><i>(default = ranging information is printed to the listing file)</i>

<h4><a name="CPLEXscaind">
scaind</a>
<i> (integer)</i> matrix scaling on/off</h4><p>

This option influences the scaling of the problem matrix.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>No scaling</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Standard scaling.
An equilibration scaling method is implemented which is generally very
effective.</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Modified, more aggressive scaling method.
This method can produce improvements on some problems. This scaling
should be used if the problem is observed to have difficulty staying
feasible during the solution process.</td></tr>
</table>

<h4><a name="CPLEXsiftalg">
siftalg</a>
<i> (integer)</i> sifting subproblem algorithm</h4><p>

Sets the algorithm to be used for solving sifting subproblems.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Primal simplex</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Dual simplex</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Network simplex</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Barrier</td></tr>
</table>

<h4><a name="CPLEXsiftdisplay">
siftdisplay</a>
<i> (integer)</i> sifting display level</h4><p>

Determines the amount of sifting progress information to be displayed.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>No display</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Display major iterations</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Display LP subproblem information</td></tr>
</table>

<h4><a name="CPLEXsiftitlim">
siftitlim</a>
<i> (integer)</i> limit on sifting iterations</h4><p>

Sets the maximum number of sifting iterations that may be performed if
convergence to optimality has not been reached.

<br><i>(default = large)</i>

<h4><a name="CPLEXsimdisplay">
simdisplay</a>
<i> (integer)</i> simplex display level</h4><p>

This option controls what Cplex reports (normally to the screen)
during optimization. The amount of information displayed increases as
the setting value increases.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>No iteration messages are issued until the optimal solution is reported</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>An iteration log message will be issued after each refactorization.
Each entry will contain the iteration count and scaled infeasibility
or objective value.</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>An iteration log message will be issued after each iteration.
The variables, slacks and artificials entering and leaving the basis
will also be reported.</td></tr>
</table>

<h4><a name="CPLEXsinglim">
singlim</a>
<i> (integer)</i> limit on singularity repairs</h4><p>

The singularity limit setting restricts the number of times Cplex will
attempt to repair the basis when singularities are encountered. Once
the limit is exceeded, Cplex replaces the current basis with the best
factorizable basis that has been found. Any non-negative integer value
is valid.

<br><i>(default = 10)</i>

<h4><a name="CPLEXsolnpool">
solnpool</a>
<i> (string)</i> solution pool file name</h4><p>

The solution pool enables you to generate and store multiple solutions
to a MIP problem. The option expects a GDX filename. This GDX file
name contains the information about the different solutions generated
by Cplex. Inside your GAMS program you can process the GDX file and
read the different solution point files. Please check the GAMS/Cplex
solver guide document and the example model <tt>solnpool.gms</tt> from
the GAMS model library.


<h4><a name="CPLEXsolnpoolagap">
solnpoolagap</a>
<i> (real)</i> absolute tolerance for the solutions in the solution pool</h4><p>

Sets an absolute tolerance on the objective bound for the solutions in
the solution pool. Solutions that are worse (either greater in the
case of a minimization, or less in the case of a maximization) than
the objective of the incumbent solution according to this measure are
not kept in the solution pool.
<p>
Values of the solution pool absolute gap and the solution pool
relative gap <a href="#CPLEXsolnpoolgap">solnpoolgap</a> may differ: For
example, you may specify that solutions must be within 15 units by
means of the solution pool absolute gap and also within 1% of the
incumbent by means of the solution pool relative gap. A solution is
accepted in the pool only if it is valid for both the relative and the
absolute gaps.
<p>
The solution pool absolute gap parameter can also be used as a
stopping criterion for the populate procedure: if populate cannot
enumerate any more solutions that satisfy this objective quality, then
it will stop. In the presence of both an absolute and a relative
solution pool gap parameter, populate will stop when the smaller of
the two is reached.

<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXsolnpoolcapacity">
solnpoolcapacity</a>
<i> (integer)</i> limits of solutions kept in the solution pool</h4><p>

Limits the number of solutions kept in the solution pool. At most,
<i>solnpoolcapacity</i> solutions will be stored in the pool.
Superfluous solutions are managed according to the replacement
strategy set by the solution pool replacement parameter <a
href="#CPLEXsolnpoolreplace">solnpoolreplace</a>.
<p>
The optimization (whether by MIP optimization or the populate
procedure) will not stop if more than <i>solnpoolcapacity</i> are
generated. Instead, stopping criteria are regular node and time limits
and <a href="#CPLEXpopulatelim">populatelim</a>, <a href="#CPLEXsolnpoolgap">solnpoolgap</a>
and <a href="#CPLEXsolnpoolagap">solnpoolagap</a>.

<br><i>(default = 2100000000)</i>

<h4><a name="CPLEXsolnpoolgap">
solnpoolgap</a>
<i> (real)</i> relative tolerance for the solutions in the solution pool</h4><p>

Sets a relative tolerance on the objective bound for the solutions in
the solution pool. Solutions that are worse (either greater in the
case of a minimization, or less in the case of a maximization) than
the incumbent solution by this measure are not kept in the solution
pool.
<p>
Values of the solution pool absolute gap <a
href="#CPLEXsolnpoolagap">solnpoolagap</a> and the solution pool relative
gap may differ: For example, you may specify that solutions must be
within 15 units by means of the solution pool absolute gap and within
1% of the incumbent by means of the solution pool relative gap. A
solution is accepted in the pool only if it is valid for both the
relative and the absolute gaps.
<p>
The solution pool relative gap parameter can also be used as a
stopping criterion for the populate procedure: if populate cannot
enumerate any more solutions that satisfy this objective quality, then
it will stop. In the presence of both an absolute and a relative
solution pool gap parameter, populate will stop when the smaller of
the two is reached.

<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXsolnpoolintensity">
solnpoolintensity</a>
<i> (integer)</i> solution pool intensity for ability to produce multiple solutions</h4><p>

Controls the trade-off between the number of solutions generated for
the solution pool and the amount of time or memory consumed. This
parameter applies both to MIP optimization and to the populate
procedure.
<p>
Values from 1 to 4 invoke increasing effort to find larger numbers of
solutions. Higher values are more expensive in terms of time and
memory but are likely to yield more solutions.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic.
Its default value, 0 , lets Cplex choose which intensity to apply.</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Mild: generate few solutions quickly.
For value 1, the performance of MIP optimization is not
affected. There is no slowdown and no additional consumption of memory
due to this setting. However, populate will quickly generate only a
small number of solutions. Generating more than a few solutions with
this setting will be slow. When you are looking for a larger number of
solutions, use a higher value of this parameter.</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Moderate: generate a larger number of solutions.
For value 2, some information is stored in the branch and cut tree so
that it is easier to generate a larger number of solutions. This
storage has an impact on memory used but does not lead to a slowdown
in the performance of MIP optimization. With this value, calling
populate is likely to yield a number of solutions large enough for
most purposes. This value is a good choice for most models.</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Aggressive: generate many solutions and expect performance penalty.
For value 3, the algorithm is more aggressive in computing and storing
information in order to generate a large number of solutions. Compared
to values 1 and 2, this value will generate a larger number of
solutions, but it will slow MIP optimization and increase memory
consumption. Use this value only if setting this parameter to 2 does
not generate enough solutions.</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Very aggressive: enumerate all practical solutions.
For value 4, the algorithm generates all solutions to your model. Even
for small models, the number of possible solutions is likely to be
huge; thus enumerating all of them will take time and consume a large
quantity of memory.</td></tr>
</table>

<h4><a name="CPLEXsolnpoolpop">
solnpoolpop</a>
<i> (integer)</i> methods to populate the solution pool</h4><p>

Regular MIP optimization automatically adds incumbents to the solution
pool as they are discovered. Cplex also provides a procedure known as
<i>populate</i> specifically to generate multiple solutions. You can
invoke this procedure either as an alternative to the usual MIP
optimizer or as a successor to the MIP optimizer. You can also invoke
this procedure many times in a row in order to explore the solution
space differently (see option <a
href="#CPLEXsolnpoolpoprepeat">solnpoolpoprepeat</a>). In particular, you may
invoke this procedure multiple times to find additional solutions,
especially if the first solutions found are not satisfactory.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>1</td><td>Just collect the incumbents found during regular optimization</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Calls the populate procedure</td></tr>
</table>

<h4><a name="CPLEXsolnpoolpopdel">
solnpoolpopdel</a>
<i> (string)</i> file with solution numbers to delete from the solution pool</h4><p>

After the GAMS program specified in <a
href="#CPLEXsolnpoolpoprepeat">solnpoolpoprepeat</a> determined to continue
the search for alternative solutions, the file specified by this
option is read in. The solution numbers present in this file will be
delete from the solution pool before the populate routine is called
again. The file is automatically deleted by the GAMS/Cplex link after
processing.


<h4><a name="CPLEXsolnpoolpoprepeat">
solnpoolpoprepeat</a>
<i> (string)</i> method to decide if populating the solution should be repeated</h4><p>

After the termination of the populate procedure (see option <a
href="#CPLEXsolnpoolpop">solnpoolpop</a>). The GAMS program specified in
this option will be called which can examine the solutions in the
solution pool and can decide to run the populate procedure again. If
the GAMS program terminates normally (not compilation or execution
time error) the search for new alternative solutions will be repeated.


<h4><a name="CPLEXsolnpoolprefix">
solnpoolprefix</a>
<i> (string)</i> file name prefix for GDX solution files</h4><p>


<br><i>(default = soln)</i>

<h4><a name="CPLEXsolnpoolreplace">
solnpoolreplace</a>
<i> (integer)</i> strategy for replacing a solution in the solution pool</h4><p>


<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Replace the first solution (oldest) by the most recent solution; first in, first out</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Replace the solution which has the worst objective</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Replace solutions in order to build a set of diverse solutions</td></tr>
</table>

<h4><a name="CPLEXsolutiontarget">
solutiontarget</a>
<i> (integer)</i> type of solution when solving a nonconvex continuous quadratic model</h4><p>

This parameter specifies the type of solution when solving a
nonconvex, continuous quadratic model. This parameter affects the
behavior only when CPLEX uses the barrier algorithm without
crossover to solve a nonconvex continuous quadratic model (QP); that
is, the variables of the model are continuous, the objective function
includes a quadratic term, and the objective function is not positive
semi-definite (PSD).

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic.
CPLEX first attempts to compute a provably optimal solution. If CPLEX
cannot compute a provably optimal solution because the objective
function is not convex, CPLEX will return with an error (Q is not
PSD).</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Search for a globally optimal solution to a convex model</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Search for a solution that satisfies first-order optimality conditions no optimality guarantee.
CPLEX first attempt to compute a provably optimal solution. If CPLEX
cannot compute a provably optimal solution because the objective
function is not convex, CPLEX searches for a solution that satisfies
first-order optimality conditions but is not necessarily globally
optimal.</td></tr>
</table>

<h4><a name="CPLEXsolvefinal">
solvefinal</a>
<i> (integer)</i> switch to solve the problem with fixed discrete variables</h4><p>

Sometimes the solution process after the branch-and-cut that solves
the problem with fixed discrete variables takes a long time and the
user is interested in the primal values of the solution only. In these
cases, <tt>solvefinal</tt> can be used to turn this final solve
off. Without the final solve no proper marginal values are available
and only zeros are returned to GAMS.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Do not solve the fixed problem</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Solve the fixed problem and return duals</td></tr>
</table>

<h4><a name="CPLEXstartalg">
startalg</a>
<i> (integer)</i> MIP starting algorithm</h4><p>

Selects the algorithm to use for the initial relaxation of a MIP.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Primal simplex</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Dual simplex</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Network simplex</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Barrier</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Sifting</td></tr>
<tr valign="top"><td width=20 align=right>6</td><td>Concurrent</td></tr>
</table>

<h4><a name="CPLEXstrongcandlim">
strongcandlim</a>
<i> (integer)</i> size of the candidates list for strong branching</h4><p>

Limit on the length of the candidate list for strong branching
(<a href="#CPLEXvarsel">varsel</a> = 3).

<br><i>(default = 10)</i>

<h4><a name="CPLEXstrongitlim">
strongitlim</a>
<i> (integer)</i> limit on iterations per branch for strong branching</h4><p>

Limit on the number of iterations per branch in strong branching
(<a href="#CPLEXvarsel">varsel</a> = 3). The default value of 0 causes the limit
to be chosen automatically which is normally satisfactory. Try
reducing this value if the time per node seems excessive. Try
increasing this value if the time per node is reasonable but Cplex is
making little progress.

<br><i>(default = 0)</i>

<h4><a name="CPLEXsubalg">
subalg</a>
<i> (integer)</i> algorithm for subproblems</h4><p>

Strategy for solving linear sub-problems at each node.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Primal simplex</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Dual simplex</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Network optimizer followed by dual simplex</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Barrier with crossover</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Sifting</td></tr>
</table>

<h4><a name="CPLEXsubmipnodelim">
submipnodelim</a>
<i> (integer)</i> limit on number of nodes in an RINS subMIP</h4><p>

Controls the number of nodes explored in an RINS subMIP. See option
<a href="#CPLEXrinsheur">rinsheur</a>.

<br><i>(default = 500)</i>

<h4><a name="CPLEXsymmetry">
symmetry</a>
<i> (integer)</i> symmetry breaking cuts</h4><p>

Determines whether symmetry breaking cuts may be added, during the
preprocessing phase, to a MIP model.

<br><i>(default = -1)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Turn off symmetry breaking</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Moderate level of symmetry breaking</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Aggressive level of symmetry breaking</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Very aggressive level of symmetry breaking</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Highly aggressive level of symmetry breaking</td></tr>
<tr valign="top"><td width=20 align=right>5</td><td>Extremely aggressive level of symmetry breaking</td></tr>
</table>

<h4><a name="CPLEXthreads">
threads</a>
<i> (integer)</i> global default thread count<br>&nbsp;&nbsp;&nbsp;Synonym:
gthreads</h4><p>

Default number of parallel threads allowed for any solution
method. Non-positive values are interpreted as the number of cores to
leave free so setting threads to 0 uses all available cores while
setting threads to -1 leaves one core free for other tasks. Cplex does not
understand negative values for the <tt>threads</tt> parameter. GAMS/Cplex
will translate this is a non-negative number by applying the following
formula: max(1,number of cores-|threads|)

<br><i>(default = GAMS Threads)</i>

<h4><a name="CPLEXtilim">
tilim</a>
<i> (real)</i> overrides the GAMS ResLim option<br>&nbsp;&nbsp;&nbsp;Synonym:
reslim</h4><p>

The time limit setting determines the amount of time in seconds that
Cplex will continue to solve a problem.  This Cplex option overrides
the GAMS ResLim option. Any non-negative value is valid.

<br><i>(default = GAMS ResLim)</i>

<h4><a name="CPLEXtrelim">
trelim</a>
<i> (real)</i> maximum space in memory for tree</h4><p>

Sets an absolute upper limit on the size (in megabytes) of the branch
and cut tree. If this limit is exceeded, Cplex terminates
optimization.

<br><i>(default = 1e+075)</i>

<h4><a name="CPLEXtuning">
tuning</a>
<i> (string)</i> invokes parameter tuning tool</h4><p>

Invokes the Cplex parameter tuning tool. The mandatory value following
the keyword specifies a GAMS/Cplex option file. All options found in
this option file will be used but not modified during the tuning. A
sequence of file names specifying existing problem files may follow
the option file name. The files can be in <a href="#CPLEXwritelp">LP</a>, <a
href="#CPLEXwritemps">MPS</a> or <a href="#CPLEXwritesav">SAV</a> format. Cplex
will tune the parameters either for the problem provided by GAMS (no
additional problem files specified) or for the suite of problems listed
after the GAMS/Cplex option file name without considering the problem
provided by GAMS (use option <a href="#CPLEXwritesav">writesav</a> to create
a SAV file of the problem provided by GAMS and include this name in
the list of problems). The result of such a run is the updated
GAMS/Cplex option file with a tuned set of parameters. The solver and
model status returned to GAMS will be <tt>NORMAL COMPLETION</tt> and
<tt>NO SOLUTION</tt>. Tuning is incompatible with the BCH facility and
other advanced features of GAMS/Cplex.


<h4><a name="CPLEXtuningdettilim">
tuningdettilim</a>
<i> (real)</i> tuning deterministic time limit per model or suite</h4><p>


<br><i>(default = 1e+007)</i>

<h4><a name="CPLEXtuningdisplay">
tuningdisplay</a>
<i> (integer)</i> level of information reported by the tuning tool</h4><p>

Specifies the level of information reported by the tuning tool as it works.

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>0</td><td>Turn off display</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Display standard minimal reporting</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Display standard report plus parameter settings being tried</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Display exhaustive report and log</td></tr>
</table>

<h4><a name="CPLEXtuningmeasure">
tuningmeasure</a>
<i> (integer)</i> measure for evaluating progress for a suite of models</h4><p>

Controls the measure for evaluating progress when a suite of models is
being tuned.  Choices are mean average and minmax of time to compare
different parameter sets over a suite of models

<br><i>(default = 1)</i>
<table>
<tr valign="top"><td width=20 align=right>1</td><td>mean average</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>minmax</td></tr>
</table>

<h4><a name="CPLEXtuningrepeat">
tuningrepeat</a>
<i> (integer)</i> number of times tuning is to be repeated on perturbed versions</h4><p>

Specifies the number of times tuning is to be repeated on perturbed
versions of a given problem. The problem is perturbed automatically by
Cplex permuting its rows and columns. This repetition is helpful when
only one problem is being tuned, as repeated perturbation and
re-tuning may lead to more robust tuning results. This parameter
applies to only one problem in a tuning session.

<br><i>(default = 1)</i>

<h4><a name="CPLEXtuningtilim">
tuningtilim</a>
<i> (real)</i> tuning time limit per model or suite</h4><p>

Sets a time limit per model and per test set (that is, suite of models).
<p>
As an example, suppose that you want to spend an overall amount of
time tuning the parameter settings for a given model, say, 2000
seconds. Also suppose that you want Cplex to make multiple attempts
within that overall time limit to tune the parameter settings for your
model. Suppose further that you want to set a time limit on each of
those attempts, say, 200 seconds per attempt. In this case you need to
specify an overall time limit of 2000 using GAMS option
<tt>reslim</tt> or Cplex option <a href="#CPLEXtilim">tilim</a> and
<tt>tuningtilim</tt> to 200.

<br><i>(default = 0.2*GAMS ResLim)</i>

<h4><a name="CPLEXuserincbcall">
userincbcall</a>
<i> (string)</i> The GAMS command line to call the incumbent checking program</h4><p>

The GAMS command line (minus the GAMS executable name) to call the
incumbent checking routine. The incumbent is rejected if the GAMS
program terminates normally. In case of a compilation or execution
error, the incumbent is accepted.


<h4><a name="CPLEXvarsel">
varsel</a>
<i> (integer)</i> variable selection strategy at each node</h4><p>

This option is used to set the rule for selecting the branching
variable at the node which has been selected for branching. The
default value of 0 allows Cplex to select the best rule based on the
problem and its progress.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Branch on variable with minimum infeasibility.
This rule may lead more quickly to a first integer feasible solution,
but will usually be slower overall to reach the optimal integer
solution.</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Branch variable automatically selected</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Branch on variable with maximum infeasibility.
This rule forces larger changes earlier in the tree, which tends to
produce faster overall times to reach the optimal integer solution.</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Branch based on pseudo costs.
Generally, the pseudo-cost setting is more effective when the problem
contains complex trade-offs and the dual values have an economic
interpretation.</td></tr>
<tr valign="top"><td width=20 align=right>3</td><td>Strong Branching.
This setting causes variable selection based on partially solving a
number of subproblems with tentative branches to see which branch is
most promising. This is often effective on large, difficult problems.</td></tr>
<tr valign="top"><td width=20 align=right>4</td><td>Branch based on pseudo reduced costs</td></tr>
</table>

<h4><a name="CPLEXworkdir">
workdir</a>
<i> (string)</i> directory for working files</h4><p>

The name of an existing directory into which Cplex may store temporary
working files. Used for MIP node files and by out-of-core Barrier.

<br><i>(default = current or project directory)</i>

<h4><a name="CPLEXworkmem">
workmem</a>
<i> (real)</i> memory available for working storage</h4><p>

Upper limit on the amount of memory, in megabytes, that Cplex is
permitted to use for working files. See parameter <a href="#CPLEXworkdir">workdir</a>.

<br><i>(default = 128)</i>

<h4><a name="CPLEXwritebas">
writebas</a>
<i> (string)</i> produce a Cplex basis file</h4><p>

Write a basis file.


<h4><a name="CPLEXwriteflt">
writeflt</a>
<i> (string)</i> produce a Cplex solution pool filter file</h4><p>

Write the diversity filter to a Cplex FLT file.


<h4><a name="CPLEXwritelp">
writelp</a>
<i> (string)</i> produce a Cplex LP file</h4><p>

Write a file in Cplex LP format.


<h4><a name="CPLEXwritemps">
writemps</a>
<i> (string)</i> produce a Cplex MPS file</h4><p>

Write an MPS problem file.


<h4><a name="CPLEXwritemst">
writemst</a>
<i> (string)</i> produce a Cplex mst file</h4><p>

Write a Cplex mst (containing the mip start) file.


<h4><a name="CPLEXwriteord">
writeord</a>
<i> (string)</i> produce a Cplex ord file</h4><p>

Write a Cplex ord (containing priority and branch direction
information) file.


<h4><a name="CPLEXwriteparam">
writeparam</a>
<i> (string)</i> produce a Cplex parameter file with all active options</h4><p>

Write a Cplex parameter (containing all modified Cplex options) file.


<h4><a name="CPLEXwritepre">
writepre</a>
<i> (string)</i> produce a Cplex LP/MPS/SAV file of the presolved problem<br>&nbsp;&nbsp;&nbsp;Synonym:
writepremps</h4><p>

Write a Cplex LP, MPS, or SAV file of the presolved problem. The file
extension determines the problem format. For example, <tt>writepre
presolved.lp</tt> creates a file <tt>presolved.lp</tt> in Cplex LP
format.


<h4><a name="CPLEXwritesav">
writesav</a>
<i> (string)</i> produce a Cplex binary problem file</h4><p>

Write a binary problem file.


<h4><a name="CPLEXzerohalfcuts">
zerohalfcuts</a>
<i> (integer)</i> zero-half cuts</h4><p>

Decides whether or not to generate zero-half cuts for the problem. The
value 0, the default, specifies that the attempt to generate zero-half
cuts should continue only if it seems to be helping. If the dual bound
of your model does not make sufficient progress, consider setting this
parameter to 2 to generate zero-half cuts more aggressively.

<br><i>(default = 0)</i>
<table>
<tr valign="top"><td width=20 align=right>-1</td><td>Off</td></tr>
<tr valign="top"><td width=20 align=right>0</td><td>Automatic</td></tr>
<tr valign="top"><td width=20 align=right>1</td><td>Generate zero-half cuts moderately</td></tr>
<tr valign="top"><td width=20 align=right>2</td><td>Generate zero-half cuts aggressively</td></tr>
</table><h2><a name="dotopt">Dot Options</a></h2>

Dot options allow users to associate values to variables and equations using the
GAMS name of the variables and equations. The general syntax of a dot option in
the option file is as follows:
<pre>
<i>variable/equation-name.optionname value</i>
</pre>
Dot options can be specified for <b>all</b>, a <b>block</b>, a <b>slice</b>, and
a <b>single</b> variable and equation. The following example makes the use of
the dot option clear.

<pre>
Set i /i1*i3/;
Set j /j2*j4/;
variable v(i,j), w(i); equation e(i,j);
</pre>

Consider the following lines in an option file with the imaginary option name <tt>dotopt</tt>:
<table>
<tr><td><b>Line in option file</b></td><td><b>Explanation</b></td>
<tr><td><tt>variables.dotopt 1</tt></td><td>Sets the value of <i>all</i> variables to 1</td>
<tr><td><tt>equations.dotopt 2</tt></td><td>Sets the value of <i>all</i> equations to 2</td>
<tr><td><tt>v.dotopt 3</tt></td>        <td>Sets the value of the variables in <i>block</i> <tt>v</tt> to 3</td>
<tr><td><tt>e.dotopt(*,*) 4</tt></td>   <td>Sets the value of the equations in <i>block</i> <tt>e</tt> to 4</td>
<tr><td><tt>v.dotopt(*,'j2') 5</tt></td><td>Sets the value of the variables <tt>v</tt> that have j2 in the second index position (<i>slice</i>) to 5</td>
<tr><td><tt>e.dotopt('i3',*) 6</tt></td><td>Sets the value of the equations <tt>e</tt> that have i3 in the first index position (<i>slice</i>) to 6</td>
<tr><td><tt>w.dotopt('i2') 7</tt></td>  <td>Sets the value of the <i>single</i> variables <tt>v('i2')</tt> to 7</td>
<tr><td><tt>e.dotopt('i3','j3') 8</tt>&nbsp;&nbsp;</td><td>Sets the value of the <i>single</i> equations <tt>e('i3','i3')</tt> to 8</td>
</table>

<p>The values of the dot option are applied in correspondence to the sequence they appear in the option file. In the current example, the values of dotopt for the equation <tt>e</tt> would be as follows:

<table>
<tr><td><tt>e.dotopt</tt></td><td><tt>i1</tt></td><td><tt>i2</tt></td><td><tt>i3</tt></td>
<tr><td><tt>j2</tt></td><td>4</td><td>4</td><td>6</td>
<tr><td><tt>j3</tt></td><td>4</td><td>4</td><td>8</td>
<tr><td><tt>j4</tt></td><td>4</td><td>4</td><td>6</td>
</table>

</body></html>
