/*  C code generated by apiwrapper for GAMS Version 24.0.2 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <gamsxf9glu.h>

#if defined(_WIN32)
# include <windows.h>
# define GAMSX_CALLCONV __stdcall
# if ! defined F9_CALLCONV
#  define F9_CALLCONV __stdcall
# endif
  static char winErr[] = "Windows error";
  typedef HINSTANCE soHandle_t;
#else
# define GAMSX_CALLCONV
# if ! defined F9_CALLCONV
#  define F9_CALLCONV
# endif
# include <unistd.h>
# include <dlfcn.h>
# include <sys/utsname.h>
  typedef void *soHandle_t;
#endif

typedef int (GAMSX_CALLCONV *errorCallbackFort_t) (int *errCount, const char *msg, int msgLen);
#if defined(_WIN32)
typedef __int64 INT64;
#elif defined(__LP64__) || defined(__axu__) || defined(_FCGLU_LP64_)
typedef signed long int INT64;
#else
typedef signed long long int INT64;
#endif


static soHandle_t hLibGlobal;  /* global shared library handle */
static int isLoaded = 0;
static int objectCount = 0;
static int screenIndicator = 1;
static int exceptionIndicator = 0;
static int exitIndicator = 1;
static errorCallbackFort_t errorCallbackFort = NULL;
static int APIErrorCount = 0;
static int trimflag  = 1;

#if defined(HAVE_MUTEX)
#include "gcmt.h"
static GC_mutex_t libMutex;
static GC_mutex_t objMutex;
static GC_mutex_t exceptMutex;
static int MutexIsInitialized = 0;

void gamsxF90InitMutexes(void)
{
  int rc;

  if (!MutexIsInitialized) {
    rc = GC_mutex_init (&libMutex);     assert(0==rc);
    rc = GC_mutex_init (&objMutex);     assert(0==rc);
    rc = GC_mutex_init (&exceptMutex);  assert(0==rc);
    MutexIsInitialized = 1;
  }
} /* gamsxF90InitMutexes */

void gamsxF90FiniMutexes(void)
{
  if (MutexIsInitialized) {
    GC_mutex_delete (&libMutex);
    GC_mutex_delete (&objMutex);
    GC_mutex_delete (&exceptMutex);
    MutexIsInitialized = 0;
  }
} /* gamsxF90FiniMutexes */

#  define lock(MUTEX)   if(MutexIsInitialized) GC_mutex_lock (&MUTEX);
#  define unlock(MUTEX) if(MutexIsInitialized) GC_mutex_unlock (&MUTEX);
#else
#  define lock(MUTEX)   ;
#  define unlock(MUTEX) ;
void gamsxF90InitMutexes(void) {}
void gamsxF90FiniMutexes(void) {}
#endif

typedef char string255[256];
typedef char stringf255[255];
typedef char cBuf512_t[512];
typedef int gamsxBoolean_t;
typedef union foo { void *p; INT64 i; } u64_t;


static void convertF2PAS (const char* src, char *dest, int s_len, int p_len)
{
  int i;
  int len;

  len = s_len;
  if (trimflag)
    for (;;) {
      if (len==0) break;
      if (src[len-1] != ' ') break;
      --len;
    }
  if (p_len<len)
    len = p_len;
  for (i=0; i<len; ++i)
    dest[i+1] = src[i];
  dest[0] = len;
} /* convertF2PAS */


static void convertPAS2F (const char *src, char *dest, int s_len)
{
  int i, len;
  unsigned char s0;

  for (i = 0;  i < s_len;  i++)
    dest[i] = ' ';
  s0 = src[0];
  len = s_len;
  if (s0 < len)
    len = s0;
  for (i = 0;  i < len;  i++)
    dest[i] = src[i+1];
} /* convertPAS2F */


static void convertF2C(const char* sf, char *sc, int fSize, int cSize)
{
  int i;
  int count;

  count = fSize;
  while ((count>0) && (sf[count-1]==' '))
    --count;
  if (cSize-1<count)
    count = cSize-1;
  for (i=0; i<count; ++i)
    sc[i] = sf[i];
  sc[count] = '\0';
} /* convertF2C */


static void convertC2F(const char* sc, char *sf, int s_len)
{
  int i, len;
  unsigned char s0;
  for (i=0; i<s_len; ++i)
    sf[i] = ' ';
  s0 = strlen(sc);
  len = s_len;
  if (s0 < len)
    len = s0;
  for (i=0; i<len; ++i)
    sf[i] = sc[i];
} /* convertC2F */

/* pad the buffer with blanks, including whacking the terminating nul */
static void blankPad (char *buf, int len, int siz)
{
  if (siz >= len) {
    memset (buf+len, ' ', siz-len);
  }
}

typedef gamsxBoolean_t (GAMSX_CALLCONV *XCreate_t) (void *pgamsx);
static XCreate_t XCreate = NULL;
typedef gamsxBoolean_t (GAMSX_CALLCONV *XFree_t)   (void *pgamsx);
static XFree_t   XFree = NULL;
typedef int (GAMSX_CALLCONV *XAPIVersion_t) (int api, char *msg, int *cl);
static XAPIVersion_t XAPIVersion = NULL;
typedef int (GAMSX_CALLCONV *XCheck_t) (char *ep, int nargs, int s[], char *msg);
static XCheck_t XCheck = NULL;


typedef int (GAMSX_CALLCONV *TBrkPCallBack1_F_t) (const char *fn, int len_fn, int *linNr, int *lstNr, void *usrMem);
typedef int (GAMSX_CALLCONV *TBrkPCallBack2_F_t) (const char *fn, int len_fn, int *linNr, int *lstNr, void *userMem1, void *userMem2);
typedef union fooTBrkPCallBack1 { TBrkPCallBack1_F_t f; INT64 i; } u64TBrkPCallBack1_t;
typedef union fooTBrkPCallBack2 { TBrkPCallBack2_F_t f; INT64 i; } u64TBrkPCallBack2_t;

static void errorHandling (const char *msg)
{
  int msgLen;
  int tmp;

  APIErrorCount++;
  if (screenIndicator) {
    printf("FIX ME in C glu: %s\n", msg);
    fflush(stdout);
  }
  lock(exceptMutex);
  if (errorCallbackFort) {
    msgLen = strlen(msg);
    tmp = APIErrorCount;
    if (errorCallbackFort(&tmp, msg, msgLen)) {
      unlock(exceptMutex);
      exit(123);
    }
  }
  unlock(exceptMutex);
  assert(!exceptionIndicator);
  if (exitIndicator)
    exit(123);
}



/* Prototypes for Dummy Functions */
int  GAMSX_CALLCONV d_gamsxRunExecDLL (void *pgamsx, void *optPtr, const char *sysDir, int AVerbose, char *Msg);
int  GAMSX_CALLCONV d_gamsxShowError (void *pgamsx, const char *fNameLog, char *errorLine, char *errorTyp, char *gmsLine);
void  GAMSX_CALLCONV d_gamsxAddBreakPoint (void *pgamsx, const char *fn, int lineNr);
void  GAMSX_CALLCONV d_gamsxClearBreakPoints (void *pgamsx);
int  GAMSX_CALLCONV d_gamsxSystemInfo (void *pgamsx, int *NrSy, int *NrUel);
int  GAMSX_CALLCONV d_gamsxSymbolInfo (void *pgamsx, int SyNr, char *SyName, char *SyExplTxt, int *SyDim, int *SyTyp, int *SyCount, int *SyUserInfo);
void GAMSX_CALLCONV d_gamsxUelName (void *pgamsx, int uel, char *buf);
int  GAMSX_CALLCONV d_gamsxFindSymbol (void *pgamsx, const char *SyName);
int  GAMSX_CALLCONV d_gamsxDataReadRawStart (void *pgamsx, int SyNr, int *SyCount);
int  GAMSX_CALLCONV d_gamsxDataReadRaw (void *pgamsx, int Elements[], double Vals[], int *FDim);
int  GAMSX_CALLCONV d_gamsxDataReadDone (void *pgamsx);
int  GAMSX_CALLCONV d_gamsxDataWriteRawStart (void *pgamsx, int SyNr, int DoMerge);
int  GAMSX_CALLCONV d_gamsxDataWriteRaw (void *pgamsx, const int Elements[], const double Vals[]);
int  GAMSX_CALLCONV d_gamsxDataWriteDone (void *pgamsx);
void  GAMSX_CALLCONV d_gamsxRegisterCB1 (void *pgamsx, TBrkPCallBack1_F_t CB1, void *userMem);
void  GAMSX_CALLCONV d_gamsxRegisterCB2 (void *pgamsx, TBrkPCallBack2_F_t CB2, void *userMem1, void *userMem2);
TBrkPCallBack1_F_t GAMSX_CALLCONV d_gamsxGetCB1 (void *pgamsx);
TBrkPCallBack2_F_t GAMSX_CALLCONV d_gamsxGetCB2 (void *pgamsx);
void * GAMSX_CALLCONV d_gamsxGetCB1UM (void *pgamsx);
void * GAMSX_CALLCONV d_gamsxGetCB2UM1 (void *pgamsx);
void * GAMSX_CALLCONV d_gamsxGetCB2UM2 (void *pgamsx);
void GAMSX_CALLCONV d_gamsxSWSet (void *pgamsx, int x);
int  GAMSX_CALLCONV d_gamsxStepThrough (void *pgamsx);
void GAMSX_CALLCONV d_gamsxStepThroughSet (void *pgamsx, int x);
int  GAMSX_CALLCONV d_gamsxRunToEnd (void *pgamsx);
void GAMSX_CALLCONV d_gamsxRunToEndSet (void *pgamsx, int x);
int  GAMSX_CALLCONV d_gamsxCB1Defined (void *pgamsx);
int  GAMSX_CALLCONV d_gamsxCB2Defined (void *pgamsx);
int  GAMSX_CALLCONV d_gamsxRunExecDLL (void *pgamsx, void *optPtr, const char *sysDir, int AVerbose, char *Msg)
{
  errorHandling("gamsxRunExecDLL could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxShowError (void *pgamsx, const char *fNameLog, char *errorLine, char *errorTyp, char *gmsLine)
{
  errorHandling("gamsxShowError could not be loaded or has wrong signature!");
  return 0;
}

void  GAMSX_CALLCONV d_gamsxAddBreakPoint (void *pgamsx, const char *fn, int lineNr)
{
  errorHandling("gamsxAddBreakPoint could not be loaded or has wrong signature!");
}

void  GAMSX_CALLCONV d_gamsxClearBreakPoints (void *pgamsx)
{
  errorHandling("gamsxClearBreakPoints could not be loaded or has wrong signature!");
}

int  GAMSX_CALLCONV d_gamsxSystemInfo (void *pgamsx, int *NrSy, int *NrUel)
{
  errorHandling("gamsxSystemInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxSymbolInfo (void *pgamsx, int SyNr, char *SyName, char *SyExplTxt, int *SyDim, int *SyTyp, int *SyCount, int *SyUserInfo)
{
  errorHandling("gamsxSymbolInfo could not be loaded or has wrong signature!");
  return 0;
}

void GAMSX_CALLCONV d_gamsxUelName (void *pgamsx, int uel, char *buf)
{
  errorHandling("gamsxUelName could not be loaded or has wrong signature!");
}

int  GAMSX_CALLCONV d_gamsxFindSymbol (void *pgamsx, const char *SyName)
{
  errorHandling("gamsxFindSymbol could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxDataReadRawStart (void *pgamsx, int SyNr, int *SyCount)
{
  errorHandling("gamsxDataReadRawStart could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxDataReadRaw (void *pgamsx, int Elements[], double Vals[], int *FDim)
{
  errorHandling("gamsxDataReadRaw could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxDataReadDone (void *pgamsx)
{
  errorHandling("gamsxDataReadDone could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxDataWriteRawStart (void *pgamsx, int SyNr, int DoMerge)
{
  errorHandling("gamsxDataWriteRawStart could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxDataWriteRaw (void *pgamsx, const int Elements[], const double Vals[])
{
  errorHandling("gamsxDataWriteRaw could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxDataWriteDone (void *pgamsx)
{
  errorHandling("gamsxDataWriteDone could not be loaded or has wrong signature!");
  return 0;
}

void  GAMSX_CALLCONV d_gamsxRegisterCB1 (void *pgamsx, TBrkPCallBack1_F_t CB1, void *userMem)
{
  errorHandling("gamsxRegisterCB1 could not be loaded or has wrong signature!");
}

void  GAMSX_CALLCONV d_gamsxRegisterCB2 (void *pgamsx, TBrkPCallBack2_F_t CB2, void *userMem1, void *userMem2)
{
  errorHandling("gamsxRegisterCB2 could not be loaded or has wrong signature!");
}

TBrkPCallBack1_F_t GAMSX_CALLCONV d_gamsxGetCB1 (void *pgamsx)
{
  errorHandling("gamsxGetCB1 could not be loaded or has wrong signature!");
  return NULL;
}

TBrkPCallBack2_F_t GAMSX_CALLCONV d_gamsxGetCB2 (void *pgamsx)
{
  errorHandling("gamsxGetCB2 could not be loaded or has wrong signature!");
  return NULL;
}

void * GAMSX_CALLCONV d_gamsxGetCB1UM (void *pgamsx)
{
  errorHandling("gamsxGetCB1UM could not be loaded or has wrong signature!");
  return NULL;
}

void * GAMSX_CALLCONV d_gamsxGetCB2UM1 (void *pgamsx)
{
  errorHandling("gamsxGetCB2UM1 could not be loaded or has wrong signature!");
  return NULL;
}

void * GAMSX_CALLCONV d_gamsxGetCB2UM2 (void *pgamsx)
{
  errorHandling("gamsxGetCB2UM2 could not be loaded or has wrong signature!");
  return NULL;
}

void GAMSX_CALLCONV d_gamsxSWSet (void *pgamsx, int x)
{
  errorHandling("gamsxSWSet could not be loaded or has wrong signature!");
}

int  GAMSX_CALLCONV d_gamsxStepThrough (void *pgamsx)
{
  errorHandling("gamsxStepThrough could not be loaded or has wrong signature!");
  return 0;
}

void GAMSX_CALLCONV d_gamsxStepThroughSet (void *pgamsx, int x)
{
  errorHandling("gamsxStepThroughSet could not be loaded or has wrong signature!");
}

int  GAMSX_CALLCONV d_gamsxRunToEnd (void *pgamsx)
{
  errorHandling("gamsxRunToEnd could not be loaded or has wrong signature!");
  return 0;
}

void GAMSX_CALLCONV d_gamsxRunToEndSet (void *pgamsx, int x)
{
  errorHandling("gamsxRunToEndSet could not be loaded or has wrong signature!");
}

int  GAMSX_CALLCONV d_gamsxCB1Defined (void *pgamsx)
{
  errorHandling("gamsxCB1Defined could not be loaded or has wrong signature!");
  return 0;
}

int  GAMSX_CALLCONV d_gamsxCB2Defined (void *pgamsx)
{
  errorHandling("gamsxCB2Defined could not be loaded or has wrong signature!");
  return 0;
}


/* return dirName on success, NULL on failure */
static char *
extractFileDirFileName (const char *fileName, char *dirName, char *fName)
{
  int fileNameLen, shave=0;
  const char *end, *s;
  char *t;

  if (NULL == fileName || NULL == dirName || fName == NULL) {
    return NULL;
  }
  fileNameLen = (int) strlen(fileName);

#if defined(_WIN32)
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '\\' != *end && ':' != *end;  end--);
  /* shave off the trailing delimiter if:
   *  it isn't the first char,
   *  it is a backslash, and
   *  it is not preceded by a delimiter
   */
  if (end > fileName && '\\' == *end
   && (! ('\\' == *(end-1) || ':' == *(end-1)))
     ) {
    end--; shave=1;
  }
#else
  /* non-Windows: implicitly, this is the Unix version */
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '/' != *end;  end--);

  if (end > fileName && '/' == *end) {
    end--; shave=1;
  }
#endif  /* if defined(_WIN32) */

  for (s = fileName, t = dirName;  s <= end;  s++, t++)
    *t = *s;
  *t = '\0';

  if (shave) s++;
  for (t = fName;  s <= fileName + fileNameLen - 1;  s++, t++)
    *t = *s;
  *t = '\0';

  return dirName;
} /* extractFileDirFileName */



typedef int (GAMSX_CALLCONV *gamsxRunExecDLL_t) (void *pgamsx, void *optPtr, const char *sysDir, int AVerbose, char *Msg);
static gamsxRunExecDLL_t gamsxRunExecDLL = NULL;
typedef int (GAMSX_CALLCONV *gamsxShowError_t) (void *pgamsx, const char *fNameLog, char *errorLine, char *errorTyp, char *gmsLine);
static gamsxShowError_t gamsxShowError = NULL;
typedef void (GAMSX_CALLCONV *gamsxAddBreakPoint_t) (void *pgamsx, const char *fn, int lineNr);
static gamsxAddBreakPoint_t gamsxAddBreakPoint = NULL;
typedef void (GAMSX_CALLCONV *gamsxClearBreakPoints_t) (void *pgamsx);
static gamsxClearBreakPoints_t gamsxClearBreakPoints = NULL;
typedef int (GAMSX_CALLCONV *gamsxSystemInfo_t) (void *pgamsx, int *NrSy, int *NrUel);
static gamsxSystemInfo_t gamsxSystemInfo = NULL;
typedef int (GAMSX_CALLCONV *gamsxSymbolInfo_t) (void *pgamsx, int SyNr, char *SyName, char *SyExplTxt, int *SyDim, int *SyTyp, int *SyCount, int *SyUserInfo);
static gamsxSymbolInfo_t gamsxSymbolInfo = NULL;
typedef void (GAMSX_CALLCONV *gamsxUelName_t) (void *pgamsx, int uel, char *buf);
static gamsxUelName_t gamsxUelName = NULL;
typedef int (GAMSX_CALLCONV *gamsxFindSymbol_t) (void *pgamsx, const char *SyName);
static gamsxFindSymbol_t gamsxFindSymbol = NULL;
typedef int (GAMSX_CALLCONV *gamsxDataReadRawStart_t) (void *pgamsx, int SyNr, int *SyCount);
static gamsxDataReadRawStart_t gamsxDataReadRawStart = NULL;
typedef int (GAMSX_CALLCONV *gamsxDataReadRaw_t) (void *pgamsx, int Elements[], double Vals[], int *FDim);
static gamsxDataReadRaw_t gamsxDataReadRaw = NULL;
typedef int (GAMSX_CALLCONV *gamsxDataReadDone_t) (void *pgamsx);
static gamsxDataReadDone_t gamsxDataReadDone = NULL;
typedef int (GAMSX_CALLCONV *gamsxDataWriteRawStart_t) (void *pgamsx, int SyNr, int DoMerge);
static gamsxDataWriteRawStart_t gamsxDataWriteRawStart = NULL;
typedef int (GAMSX_CALLCONV *gamsxDataWriteRaw_t) (void *pgamsx, const int Elements[], const double Vals[]);
static gamsxDataWriteRaw_t gamsxDataWriteRaw = NULL;
typedef int (GAMSX_CALLCONV *gamsxDataWriteDone_t) (void *pgamsx);
static gamsxDataWriteDone_t gamsxDataWriteDone = NULL;
typedef void (GAMSX_CALLCONV *gamsxRegisterCB1_t) (void *pgamsx, TBrkPCallBack1_F_t CB1, void *userMem);
static gamsxRegisterCB1_t gamsxRegisterCB1 = NULL;
typedef void (GAMSX_CALLCONV *gamsxRegisterCB2_t) (void *pgamsx, TBrkPCallBack2_F_t CB2, void *userMem1, void *userMem2);
static gamsxRegisterCB2_t gamsxRegisterCB2 = NULL;
typedef TBrkPCallBack1_F_t (GAMSX_CALLCONV *gamsxGetCB1_t) (void *pgamsx);
static gamsxGetCB1_t gamsxGetCB1 = NULL;
typedef TBrkPCallBack2_F_t (GAMSX_CALLCONV *gamsxGetCB2_t) (void *pgamsx);
static gamsxGetCB2_t gamsxGetCB2 = NULL;
typedef void * (GAMSX_CALLCONV *gamsxGetCB1UM_t) (void *pgamsx);
static gamsxGetCB1UM_t gamsxGetCB1UM = NULL;
typedef void * (GAMSX_CALLCONV *gamsxGetCB2UM1_t) (void *pgamsx);
static gamsxGetCB2UM1_t gamsxGetCB2UM1 = NULL;
typedef void * (GAMSX_CALLCONV *gamsxGetCB2UM2_t) (void *pgamsx);
static gamsxGetCB2UM2_t gamsxGetCB2UM2 = NULL;
typedef void (GAMSX_CALLCONV *gamsxSWSet_t) (void *pgamsx, int x);
static gamsxSWSet_t gamsxSWSet=NULL;
typedef int (GAMSX_CALLCONV *gamsxStepThrough_t) (void *pgamsx);
static gamsxStepThrough_t gamsxStepThrough=NULL;
typedef void (GAMSX_CALLCONV *gamsxStepThroughSet_t) (void *pgamsx, int x);
static gamsxStepThroughSet_t gamsxStepThroughSet=NULL;
typedef int (GAMSX_CALLCONV *gamsxRunToEnd_t) (void *pgamsx);
static gamsxRunToEnd_t gamsxRunToEnd=NULL;
typedef void (GAMSX_CALLCONV *gamsxRunToEndSet_t) (void *pgamsx, int x);
static gamsxRunToEndSet_t gamsxRunToEndSet=NULL;
typedef int (GAMSX_CALLCONV *gamsxCB1Defined_t) (void *pgamsx);
static gamsxCB1Defined_t gamsxCB1Defined=NULL;
typedef int (GAMSX_CALLCONV *gamsxCB2Defined_t) (void *pgamsx);
static gamsxCB2Defined_t gamsxCB2Defined=NULL;

static soHandle_t
loadLib (const char *libName, char **errMsg)
{
  soHandle_t h;

#if defined(_WIN32)
  h = LoadLibrary (libName);
  if (NULL == h) {
    *errMsg = winErr;
  }
  else {
    *errMsg = NULL;
  }
#else
  (void) dlerror();
  h = dlopen (libName, RTLD_NOW);
  if (NULL == h) {
    *errMsg = dlerror();
  }
  else {
    *errMsg = NULL;
  }
#endif

  return h;
} /* loadLib */

static int
unLoadLib (soHandle_t h)
{
  int rc;

#if defined(_WIN32)
  rc = FreeLibrary (h);
  return ! rc;
#else
  rc = dlclose (h);
#endif
  return rc;
} /* unLoadLib */

static void *
loadSym (soHandle_t h, const char *sym, char **errMsg)
{
  void *s;
  const char *from;
  char *to;
  const char *tripSym;
  char lcbuf[257];
  char ucbuf[257];
  char ocbuf[257];
  size_t symLen;
  int trip;

  /* search in this order:
   *  1. original
   *  2. lower_
   *  3. upper_
   *  4. original_
   *  5. lower
   *  6. upper
   */

  symLen = 0;
  for (trip = 1;  trip <= 6;  trip++) {
    switch (trip) {
    case 1:                             /* original */
      tripSym = sym;
      break;
    case 2:                             /* lower_ */
      for (from = sym, to = lcbuf;  *from;  from++, to++) {
        *to = tolower(*from);
      }
      symLen = from - sym;
      *to++ = '_';
      *to = '\0';
      tripSym = lcbuf;
      break;
    case 3:                             /* upper_ */
      for (from = sym, to = ucbuf;  *from;  from++, to++) {
        *to = toupper(*from);
      }
      *to++ = '_';
      *to = '\0';
      tripSym = ucbuf;
      break;
    case 4:                             /* original_ */
      memcpy (ocbuf, sym, symLen);
      ocbuf[symLen] = '_';
      ocbuf[symLen+1] = '\0';
      tripSym = ocbuf;
      break;
    case 5:                             /* lower */
      lcbuf[symLen] = '\0';
      tripSym = lcbuf;
      break;
    case 6:                             /* upper */
      ucbuf[symLen] = '\0';
      tripSym = ucbuf;
      break;
    default:
      tripSym = sym;
    } /* end switch */
#if defined(_WIN32)
#  if defined(HAVE_INTPTR_T)
    s = (void *)(intptr_t)GetProcAddress (h, tripSym);
#  else
    s = (void *)GetProcAddress (h, tripSym);
#  endif
    if (NULL != s) {
      return s;
    }
#else
    (void) dlerror();
    s = dlsym (h, tripSym);
    *errMsg = dlerror();
    if (NULL == *errMsg) {
      return s;
    }
#endif
  } /* end loop over symbol name variations */

  return NULL;
} /* loadSym */

/* TNAME = type name, ENAME = exported name */
#if defined(HAVE_INTPTR_T)
#  define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) (intptr_t) loadSym (hLibGlobal, symName, &errMsg); if (NULL == TNAME) goto symMissing
#  define LOADIT_ERR_OK(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) (intptr_t) loadSym (hLibGlobal, symName, &errMsg)
#else
#  define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (hLibGlobal, symName, &errMsg); if (NULL == TNAME) goto symMissing
#  define LOADIT_ERR_OK(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (hLibGlobal, symName, &errMsg)
#endif

#if ! defined(GMS_DLL_BASENAME)
# define GMS_DLL_BASENAME "gamsxdclib"
#endif
#if defined(_WIN32)
# if ! defined(GMS_DLL_PREFIX)
#  define GMS_DLL_PREFIX ""
# endif
# if ! defined(GMS_DLL_EXTENSION)
#  define GMS_DLL_EXTENSION ".dll"
# endif
# if ! defined(GMS_DLL_SUFFIX)
#  if defined(_WIN64)
#   define GMS_DLL_SUFFIX "64"
#  else
#   define GMS_DLL_SUFFIX ""
#  endif
# endif

#else  /* start non-Windows */

# if ! defined(GMS_DLL_PREFIX)
#  define GMS_DLL_PREFIX "lib"
# endif
# if ! defined(GMS_DLL_EXTENSION)
#  if defined(__APPLE__)
#   define GMS_DLL_EXTENSION ".dylib"
#  else
#   define GMS_DLL_EXTENSION ".so"
#  endif
# endif
# if ! defined(GMS_DLL_SUFFIX)
#  if defined(__WORDSIZE)
#   if 64 == __WORDSIZE
#    define GMS_DLL_SUFFIX "64"
#   else
#    define GMS_DLL_SUFFIX ""
#   endif
#  elif defined(__SIZEOF_POINTER__)
#   if 4 == __SIZEOF_POINTER__
#    define GMS_DLL_SUFFIX ""
#   elif 8 == __SIZEOF_POINTER__
#    define GMS_DLL_SUFFIX "64"
#   endif
#  elif defined(__sparcv9)
#   define GMS_DLL_SUFFIX "64"
#  elif defined(__sparc)
/*  check __sparc after __sparcv9, both are defined for 64-bit */
#   define GMS_DLL_SUFFIX ""
#  endif
# endif /* ! defined(GMS_DLL_SUFFIX) */
#endif

/* XLibraryLoad: return 0 on success, ~0 on failure */
static int
XLibraryLoad (const char *dllName, char *errBuf, int errBufSize)
{
  char *errMsg;
  const char *symName;
  int rc, elen, cl;
  char *ebuf;

  if (isLoaded)
    return 0;
  hLibGlobal = loadLib (dllName, &errMsg);
  if (NULL == hLibGlobal) {
    if (NULL != errBuf) {
      elen = errBufSize;  ebuf = errBuf;
      rc = sprintf (ebuf, "%.*s", elen, "Could not load shared library ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, dllName);
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, ": ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, errMsg);
      elen -= rc;  ebuf+= rc;
      errBuf[errBufSize-1] = '\0';
    }
    return 1;
  }
  else {
     /* printf ("Loaded shared library %s successfully\n", dllName); */
    if (errBuf && errBufSize)
      errBuf[0] = '\0';
  }

  LOADIT(XCreate, "XCreate");
  LOADIT(XFree, "XFree");
  LOADIT(XCheck, "CXCheck");
  LOADIT(XAPIVersion, "CXAPIVersion");

  if (!XAPIVersion(1,errBuf,&cl))
    return 1;

  { int s[]={3,1,11,3,12};
    if(!XCheck("gamsxRunExecDLL",4,s,errBuf))  gamsxRunExecDLL=&d_gamsxRunExecDLL;
    else { LOADIT(gamsxRunExecDLL,"gamsxRunExecDLL"); }  }
  { int s[]={15,11,12,12,12};
    if(!XCheck("gamsxShowError",4,s,errBuf))  gamsxShowError=&d_gamsxShowError;
    else { LOADIT(gamsxShowError,"gamsxShowError"); }  }
  { int s[]={0,11,3};
    if(!XCheck("gamsxAddBreakPoint",2,s,errBuf))  gamsxAddBreakPoint=&d_gamsxAddBreakPoint;
    else { LOADIT(gamsxAddBreakPoint,"gamsxAddBreakPoint"); }  }
  { int s[]={0};
    if(!XCheck("gamsxClearBreakPoints",0,s,errBuf))  gamsxClearBreakPoints=&d_gamsxClearBreakPoints;
    else { LOADIT(gamsxClearBreakPoints,"gamsxClearBreakPoints"); }  }
  { int s[]={3,21,21};
    if(!XCheck("gamsxSystemInfo",2,s,errBuf))  gamsxSystemInfo=&d_gamsxSystemInfo;
    else { LOADIT(gamsxSystemInfo,"gamsxSystemInfo"); }  }
  { int s[]={3,3,12,12,21,21,21,21};
    if(!XCheck("gamsxSymbolInfo",7,s,errBuf))  gamsxSymbolInfo=&d_gamsxSymbolInfo;
    else { LOADIT(gamsxSymbolInfo,"gamsxSymbolInfo"); }  }
  { int s[]={12,3};
    if(!XCheck("gamsxUelName",1,s,errBuf))  gamsxUelName=&d_gamsxUelName;
    else { LOADIT(gamsxUelName,"gamsxUelName"); }  }
  { int s[]={3,11};
    if(!XCheck("gamsxFindSymbol",1,s,errBuf))  gamsxFindSymbol=&d_gamsxFindSymbol;
    else { LOADIT(gamsxFindSymbol,"gamsxFindSymbol"); }  }
  { int s[]={3,3,21};
    if(!XCheck("gamsxDataReadRawStart",2,s,errBuf))  gamsxDataReadRawStart=&d_gamsxDataReadRawStart;
    else { LOADIT(gamsxDataReadRawStart,"gamsxDataReadRawStart"); }  }
  { int s[]={3,52,54,21};
    if(!XCheck("gamsxDataReadRaw",3,s,errBuf))  gamsxDataReadRaw=&d_gamsxDataReadRaw;
    else { LOADIT(gamsxDataReadRaw,"gamsxDataReadRaw"); }  }
  { int s[]={3};
    if(!XCheck("gamsxDataReadDone",0,s,errBuf))  gamsxDataReadDone=&d_gamsxDataReadDone;
    else { LOADIT(gamsxDataReadDone,"gamsxDataReadDone"); }  }
  { int s[]={3,3,15};
    if(!XCheck("gamsxDataWriteRawStart",2,s,errBuf))  gamsxDataWriteRawStart=&d_gamsxDataWriteRawStart;
    else { LOADIT(gamsxDataWriteRawStart,"gamsxDataWriteRawStart"); }  }
  { int s[]={3,51,53};
    if(!XCheck("gamsxDataWriteRaw",2,s,errBuf))  gamsxDataWriteRaw=&d_gamsxDataWriteRaw;
    else { LOADIT(gamsxDataWriteRaw,"gamsxDataWriteRaw"); }  }
  { int s[]={3};
    if(!XCheck("gamsxDataWriteDone",0,s,errBuf))  gamsxDataWriteDone=&d_gamsxDataWriteDone;
    else { LOADIT(gamsxDataWriteDone,"gamsxDataWriteDone"); }  }
  { int s[]={0,59,1};
    if(!XCheck("gamsxRegisterCB1",2,s,errBuf))  gamsxRegisterCB1=&d_gamsxRegisterCB1;
    else { LOADIT(gamsxRegisterCB1,"FgamsxRegisterCB1"); }  }
  { int s[]={0,59,1,1};
    if(!XCheck("gamsxRegisterCB2",3,s,errBuf))  gamsxRegisterCB2=&d_gamsxRegisterCB2;
    else { LOADIT(gamsxRegisterCB2,"FgamsxRegisterCB2"); }  }
  { int s[]={59};
    if(!XCheck("gamsxGetCB1",0,s,errBuf))  gamsxGetCB1=&d_gamsxGetCB1;
    else { LOADIT(gamsxGetCB1,"FgamsxGetCB1"); }  }
  { int s[]={59};
    if(!XCheck("gamsxGetCB2",0,s,errBuf))  gamsxGetCB2=&d_gamsxGetCB2;
    else { LOADIT(gamsxGetCB2,"FgamsxGetCB2"); }  }
  { int s[]={1};
    if(!XCheck("gamsxGetCB1UM",0,s,errBuf))  gamsxGetCB1UM=&d_gamsxGetCB1UM;
    else { LOADIT(gamsxGetCB1UM,"gamsxGetCB1UM"); }  }
  { int s[]={1};
    if(!XCheck("gamsxGetCB2UM1",0,s,errBuf))  gamsxGetCB2UM1=&d_gamsxGetCB2UM1;
    else { LOADIT(gamsxGetCB2UM1,"gamsxGetCB2UM1"); }  }
  { int s[]={1};
    if(!XCheck("gamsxGetCB2UM2",0,s,errBuf))  gamsxGetCB2UM2=&d_gamsxGetCB2UM2;
    else { LOADIT(gamsxGetCB2UM2,"gamsxGetCB2UM2"); }  }
  { int s[]={0,3};
    if(!XCheck("gamsxSWSet",1,s,errBuf))  gamsxSWSet=&d_gamsxSWSet;
    else   LOADIT(gamsxSWSet,"gamsxSWSet");  }
  { int s[]={15};
    if(!XCheck("gamsxStepThrough",0,s,errBuf))  gamsxStepThrough=&d_gamsxStepThrough;
    else LOADIT(gamsxStepThrough,"gamsxStepThrough");  }
  { int s[]={0,15};
    if(!XCheck("gamsxStepThroughSet",1,s,errBuf))  gamsxStepThroughSet=&d_gamsxStepThroughSet;
    else   LOADIT(gamsxStepThroughSet,"gamsxStepThroughSet");  }
  { int s[]={15};
    if(!XCheck("gamsxRunToEnd",0,s,errBuf))  gamsxRunToEnd=&d_gamsxRunToEnd;
    else LOADIT(gamsxRunToEnd,"gamsxRunToEnd");  }
  { int s[]={0,15};
    if(!XCheck("gamsxRunToEndSet",1,s,errBuf))  gamsxRunToEndSet=&d_gamsxRunToEndSet;
    else   LOADIT(gamsxRunToEndSet,"gamsxRunToEndSet");  }
  { int s[]={15};
    if(!XCheck("gamsxCB1Defined",0,s,errBuf))  gamsxCB1Defined=&d_gamsxCB1Defined;
    else LOADIT(gamsxCB1Defined,"gamsxCB1Defined");  }
  { int s[]={15};
    if(!XCheck("gamsxCB2Defined",0,s,errBuf))  gamsxCB2Defined=&d_gamsxCB2Defined;
    else LOADIT(gamsxCB2Defined,"gamsxCB2Defined");  }

  return 0;

 symMissing:
  elen = errBufSize;  ebuf = errBuf;
  rc = sprintf (ebuf, "%.*s", elen, "Could not load symbol '");
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, symName);
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, "': ");
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, errMsg);
  elen -= rc;  ebuf+= rc;
  errBuf[errBufSize-1] = '\0';
  printf ("%s\n", errBuf);
  return 2;
} /* XLibraryLoad */

static int
libloader(const char *dllPath, const char *dllName, char *msgBuf, int msgBufSize)
{

  char dllNameBuf[512];
  int myrc = 0;
  char gms_dll_suffix[4];

#if ! defined(GMS_DLL_PREFIX)
# error "GMS_DLL_PREFIX expected but not defined"
#endif
#if ! defined(GMS_DLL_BASENAME)
# error "GMS_DLL_BASENAME expected but not defined"
#endif
#if ! defined(GMS_DLL_EXTENSION)
# error "GMS_DLL_EXTENSION expected but not defined"
#endif
#if ! defined(GMS_DLL_SUFFIX)
# if defined (_WIN32)
#   error "GMS_DLL_SUFFIX expected but not defined"
# else
  struct utsname uts;

  myrc = uname(&uts);
  if (myrc) {
    strcpy(msgBuf,"Error, cannot define library name suffix");
    return 0;
  }
  if (0 == strcmp(uts.sysname, "AIX")) /* assume AIX is 64-bit */
    strcpy (gms_dll_suffix, "64");
  else if (0 == strcmp(uts.sysname, "Darwin")) {
    /* keep Darwin test in here: fat binaries must check at run time */
    if (8 == (int)sizeof(void *))
      strcpy (gms_dll_suffix, "64");
    else
      strcpy (gms_dll_suffix, "");
  }
  else {
    strcpy(msgBuf,"Error, cannot define library name suffix");
    return 0;
  }
# endif
#else
  strcpy (gms_dll_suffix, GMS_DLL_SUFFIX);
#endif


  if (NULL != msgBuf) msgBuf[0] = '\0';

  if (! isLoaded) {
    if (NULL != dllPath && '\0' != *dllPath) {
      strncpy(dllNameBuf, dllPath, sizeof(dllNameBuf)-1);
      dllNameBuf[sizeof(dllNameBuf)-2] = '\0';
#if defined(_WIN32)
      if ('\\' != dllNameBuf[strlen(dllNameBuf)])
        strcat(dllNameBuf,"\\");
#else
      if ('/' != dllNameBuf[strlen(dllNameBuf)])
        strcat(dllNameBuf,"/");
#endif
    }
    else {
      dllNameBuf[0] = '\0';
    }
    if (NULL != dllName && '\0' != *dllName) {
      strncat(dllNameBuf, dllName, sizeof(dllNameBuf)-strlen(dllNameBuf));
      dllNameBuf[sizeof(dllNameBuf)-1] = '\0';
    }
    else {
      strncat(dllNameBuf, GMS_DLL_PREFIX GMS_DLL_BASENAME, sizeof(dllNameBuf)-strlen(dllNameBuf));
      strncat(dllNameBuf, gms_dll_suffix                 , sizeof(dllNameBuf)-strlen(dllNameBuf));
      strncat(dllNameBuf, GMS_DLL_EXTENSION              , sizeof(dllNameBuf)-strlen(dllNameBuf));
    }
    isLoaded = ! XLibraryLoad (dllNameBuf, msgBuf, msgBufSize);
    if (isLoaded) {
    }
    else {                              /* library load failed */
      myrc |= 1;
    }
  }
  return (myrc & 1) == 0;
}

#if   defined(APIWRAP_LCASE_DECOR)  /* fortran names: lower case, trailing _ */
# define C_GAMSXSTEPTHROUGH        c_gamsxstepthrough_
# define C_GAMSXRUNTOEND           c_gamsxruntoend_
# define C_GAMSXCB1DEFINED         c_gamsxcb1defined_
# define C_GAMSXCB2DEFINED         c_gamsxcb2defined_
# define C_GAMSXRUNEXECDLL         c_gamsxrunexecdll_
# define C_GAMSXSHOWERROR          c_gamsxshowerror_
# define C_GAMSXADDBREAKPOINT      c_gamsxaddbreakpoint_
# define C_GAMSXCLEARBREAKPOINTS   c_gamsxclearbreakpoints_
# define C_GAMSXSYSTEMINFO         c_gamsxsysteminfo_
# define C_GAMSXSYMBOLINFO         c_gamsxsymbolinfo_
# define C_GAMSXUELNAME            c_gamsxuelname_
# define C_GAMSXFINDSYMBOL         c_gamsxfindsymbol_
# define C_GAMSXDATAREADRAWSTART   c_gamsxdatareadrawstart_
# define C_GAMSXDATAREADRAW        c_gamsxdatareadraw_
# define C_GAMSXDATAREADDONE       c_gamsxdatareaddone_
# define C_GAMSXDATAWRITERAWSTART  c_gamsxdatawriterawstart_
# define C_GAMSXDATAWRITERAW       c_gamsxdatawriteraw_
# define C_GAMSXDATAWRITEDONE      c_gamsxdatawritedone_
# define C_GAMSXREGISTERCB1        c_gamsxregistercb1_
# define C_GAMSXREGISTERCB2        c_gamsxregistercb2_
# define C_GAMSXGETCB1             c_gamsxgetcb1_
# define C_GAMSXGETCB2             c_gamsxgetcb2_
# define C_GAMSXGETCB1UM           c_gamsxgetcb1um_
# define C_GAMSXGETCB2UM1          c_gamsxgetcb2um1_
# define C_GAMSXGETCB2UM2          c_gamsxgetcb2um2_
# define C_GAMSXCREATE             c_gamsxcreate_
# define C_GAMSXCREATED            c_gamsxcreated_
# define C_GAMSXCREATEL            c_gamsxcreatel_
# define C_GAMSXGETREADY           c_gamsxgetready_
# define C_GAMSXGETREADYD          c_gamsxgetreadyd_
# define C_GAMSXGETREADYL          c_gamsxgetreadyl_
# define C_GAMSXEXIT               c_gamsxexit_
# define C_GAMSXFREE               c_gamsxfree_
# define C_GAMSXGETAPIERRORCOUNT   c_gamsxgetapierrorcount_
# define C_GAMSXGETSCREENINDICATOR c_gamsxgetscreenindicator_
# define C_GAMSXSETSCREENINDICATOR c_gamsxsetscreenindicator_
# define C_GAMSXGETEXITINDICATOR   c_gamsxgetexitindicator_
# define C_GAMSXSETEXITINDICATOR   c_gamsxsetexitindicator_
# define C_GAMSXSETERRORCALLBACK   c_gamsxseterrorcallback_
# define C_GAMSXSWSET              c_gamsxswset_
# define C_GAMSXSTEPTHROUGHSET     c_gamsxstepthroughset_
# define C_GAMSXRUNTOENDSET        c_gamsxruntoendset_
#elif defined(APIWRAP_LCASE_NODECOR)/* fortran names: lower case, no _ */
# define C_GAMSXSTEPTHROUGH        c_gamsxstepthrough
# define C_GAMSXRUNTOEND           c_gamsxruntoend
# define C_GAMSXCB1DEFINED         c_gamsxcb1defined
# define C_GAMSXCB2DEFINED         c_gamsxcb2defined
# define C_GAMSXRUNEXECDLL         c_gamsxrunexecdll
# define C_GAMSXSHOWERROR          c_gamsxshowerror
# define C_GAMSXADDBREAKPOINT      c_gamsxaddbreakpoint
# define C_GAMSXCLEARBREAKPOINTS   c_gamsxclearbreakpoints
# define C_GAMSXSYSTEMINFO         c_gamsxsysteminfo
# define C_GAMSXSYMBOLINFO         c_gamsxsymbolinfo
# define C_GAMSXUELNAME            c_gamsxuelname
# define C_GAMSXFINDSYMBOL         c_gamsxfindsymbol
# define C_GAMSXDATAREADRAWSTART   c_gamsxdatareadrawstart
# define C_GAMSXDATAREADRAW        c_gamsxdatareadraw
# define C_GAMSXDATAREADDONE       c_gamsxdatareaddone
# define C_GAMSXDATAWRITERAWSTART  c_gamsxdatawriterawstart
# define C_GAMSXDATAWRITERAW       c_gamsxdatawriteraw
# define C_GAMSXDATAWRITEDONE      c_gamsxdatawritedone
# define C_GAMSXREGISTERCB1        c_gamsxregistercb1
# define C_GAMSXREGISTERCB2        c_gamsxregistercb2
# define C_GAMSXGETCB1             c_gamsxgetcb1
# define C_GAMSXGETCB2             c_gamsxgetcb2
# define C_GAMSXGETCB1UM           c_gamsxgetcb1um
# define C_GAMSXGETCB2UM1          c_gamsxgetcb2um1
# define C_GAMSXGETCB2UM2          c_gamsxgetcb2um2
# define C_GAMSXCREATE             c_gamsxcreate
# define C_GAMSXCREATED            c_gamsxcreated
# define C_GAMSXCREATEL            c_gamsxcreatel
# define C_GAMSXGETREADY           c_gamsxgetready
# define C_GAMSXGETREADYD          c_gamsxgetreadyd
# define C_GAMSXGETREADYL          c_gamsxgetreadyl
# define C_GAMSXEXIT               c_gamsxexit
# define C_GAMSXFREE               c_gamsxfree
# define C_GAMSXGETAPIERRORCOUNT   c_gamsxgetapierrorcount
# define C_GAMSXGETSCREENINDICATOR c_gamsxgetscreenindicator
# define C_GAMSXSETSCREENINDICATOR c_gamsxsetscreenindicator
# define C_GAMSXGETEXITINDICATOR   c_gamsxgetexitindicator
# define C_GAMSXSETEXITINDICATOR   c_gamsxsetexitindicator
# define C_GAMSXSETERRORCALLBACK   c_gamsxseterrorcallback
# define C_GAMSXSWSET              c_gamsxswset
# define C_GAMSXSTEPTHROUGHSET     c_gamsxstepthroughset
# define C_GAMSXRUNTOENDSET        c_gamsxruntoendset
#elif defined(APIWRAP_UCASE_DECOR)  /* fortran names: upper case, trailing _ */
# define C_GAMSXSTEPTHROUGH        C_GAMSXSTEPTHROUGH_
# define C_GAMSXRUNTOEND           C_GAMSXRUNTOEND_
# define C_GAMSXCB1DEFINED         C_GAMSXCB1DEFINED_
# define C_GAMSXCB2DEFINED         C_GAMSXCB2DEFINED_
# define C_GAMSXRUNEXECDLL         C_GAMSXRUNEXECDLL_
# define C_GAMSXSHOWERROR          C_GAMSXSHOWERROR_
# define C_GAMSXADDBREAKPOINT      C_GAMSXADDBREAKPOINT_
# define C_GAMSXCLEARBREAKPOINTS   C_GAMSXCLEARBREAKPOINTS_
# define C_GAMSXSYSTEMINFO         C_GAMSXSYSTEMINFO_
# define C_GAMSXSYMBOLINFO         C_GAMSXSYMBOLINFO_
# define C_GAMSXUELNAME            C_GAMSXUELNAME_
# define C_GAMSXFINDSYMBOL         C_GAMSXFINDSYMBOL_
# define C_GAMSXDATAREADRAWSTART   C_GAMSXDATAREADRAWSTART_
# define C_GAMSXDATAREADRAW        C_GAMSXDATAREADRAW_
# define C_GAMSXDATAREADDONE       C_GAMSXDATAREADDONE_
# define C_GAMSXDATAWRITERAWSTART  C_GAMSXDATAWRITERAWSTART_
# define C_GAMSXDATAWRITERAW       C_GAMSXDATAWRITERAW_
# define C_GAMSXDATAWRITEDONE      C_GAMSXDATAWRITEDONE_
# define C_GAMSXREGISTERCB1        C_GAMSXREGISTERCB1_
# define C_GAMSXREGISTERCB2        C_GAMSXREGISTERCB2_
# define C_GAMSXGETCB1             C_GAMSXGETCB1_
# define C_GAMSXGETCB2             C_GAMSXGETCB2_
# define C_GAMSXGETCB1UM           C_GAMSXGETCB1UM_
# define C_GAMSXGETCB2UM1          C_GAMSXGETCB2UM1_
# define C_GAMSXGETCB2UM2          C_GAMSXGETCB2UM2_
# define C_GAMSXCREATE             C_GAMSXCREATE_
# define C_GAMSXCREATED            C_GAMSXCREATED_
# define C_GAMSXCREATEL            C_GAMSXCREATEL_
# define C_GAMSXGETREADY           C_GAMSXGETREADY_
# define C_GAMSXGETREADYD          C_GAMSXGETREADYD_
# define C_GAMSXGETREADYL          C_GAMSXGETREADYL_
# define C_GAMSXEXIT               C_GAMSXEXIT_
# define C_GAMSXFREE               C_GAMSXFREE_
# define C_GAMSXGETAPIERRORCOUNT   C_GAMSXGETAPIERRORCOUNT_
# define C_GAMSXGETSCREENINDICATOR C_GAMSXGETSCREENINDICATOR_
# define C_GAMSXSETSCREENINDICATOR C_GAMSXSETSCREENINDICATOR_
# define C_GAMSXGETEXITINDICATOR   C_GAMSXGETEXITINDICATOR_
# define C_GAMSXSETEXITINDICATOR   C_GAMSXSETEXITINDICATOR_
# define C_GAMSXSETERRORCALLBACK   C_GAMSXSETERRORCALLBACK_
# define C_GAMSXSWSET              C_GAMSXSWSET_
# define C_GAMSXSTEPTHROUGHSET     C_GAMSXSTEPTHROUGHSET_
# define C_GAMSXRUNTOENDSET        C_GAMSXRUNTOENDSET_
#elif defined(APIWRAP_UCASE_NODECOR)/* fortran names: upper case, no _ */
# define C_GAMSXSTEPTHROUGH        C_GAMSXSTEPTHROUGH
# define C_GAMSXRUNTOEND           C_GAMSXRUNTOEND
# define C_GAMSXCB1DEFINED         C_GAMSXCB1DEFINED
# define C_GAMSXCB2DEFINED         C_GAMSXCB2DEFINED
# define C_GAMSXRUNEXECDLL         C_GAMSXRUNEXECDLL
# define C_GAMSXSHOWERROR          C_GAMSXSHOWERROR
# define C_GAMSXADDBREAKPOINT      C_GAMSXADDBREAKPOINT
# define C_GAMSXCLEARBREAKPOINTS   C_GAMSXCLEARBREAKPOINTS
# define C_GAMSXSYSTEMINFO         C_GAMSXSYSTEMINFO
# define C_GAMSXSYMBOLINFO         C_GAMSXSYMBOLINFO
# define C_GAMSXUELNAME            C_GAMSXUELNAME
# define C_GAMSXFINDSYMBOL         C_GAMSXFINDSYMBOL
# define C_GAMSXDATAREADRAWSTART   C_GAMSXDATAREADRAWSTART
# define C_GAMSXDATAREADRAW        C_GAMSXDATAREADRAW
# define C_GAMSXDATAREADDONE       C_GAMSXDATAREADDONE
# define C_GAMSXDATAWRITERAWSTART  C_GAMSXDATAWRITERAWSTART
# define C_GAMSXDATAWRITERAW       C_GAMSXDATAWRITERAW
# define C_GAMSXDATAWRITEDONE      C_GAMSXDATAWRITEDONE
# define C_GAMSXREGISTERCB1        C_GAMSXREGISTERCB1
# define C_GAMSXREGISTERCB2        C_GAMSXREGISTERCB2
# define C_GAMSXGETCB1             C_GAMSXGETCB1
# define C_GAMSXGETCB2             C_GAMSXGETCB2
# define C_GAMSXGETCB1UM           C_GAMSXGETCB1UM
# define C_GAMSXGETCB2UM1          C_GAMSXGETCB2UM1
# define C_GAMSXGETCB2UM2          C_GAMSXGETCB2UM2
# define C_GAMSXCREATE             C_GAMSXCREATE
# define C_GAMSXCREATED            C_GAMSXCREATED
# define C_GAMSXCREATEL            C_GAMSXCREATEL
# define C_GAMSXGETREADY           C_GAMSXGETREADY
# define C_GAMSXGETREADYD          C_GAMSXGETREADYD
# define C_GAMSXGETREADYL          C_GAMSXGETREADYL
# define C_GAMSXEXIT               C_GAMSXEXIT
# define C_GAMSXFREE               C_GAMSXFREE
# define C_GAMSXGETAPIERRORCOUNT   C_GAMSXGETAPIERRORCOUNT
# define C_GAMSXGETSCREENINDICATOR C_GAMSXGETSCREENINDICATOR
# define C_GAMSXSETSCREENINDICATOR C_GAMSXSETSCREENINDICATOR
# define C_GAMSXGETEXITINDICATOR   C_GAMSXGETEXITINDICATOR
# define C_GAMSXSETEXITINDICATOR   C_GAMSXSETEXITINDICATOR
# define C_GAMSXSETERRORCALLBACK   C_GAMSXSETERRORCALLBACK
# define C_GAMSXSWSET              C_GAMSXSWSET
# define C_GAMSXSTEPTHROUGHSET     C_GAMSXSTEPTHROUGHSET
# define C_GAMSXRUNTOENDSET        C_GAMSXRUNTOENDSET
#else
#error "No compile define for fortran naming convention"
No_compile_define_for_fortran_naming_convention;
#endif


/* gamsxGetReady: return false on failure, true on success */
static int gamsxGetReady (char *msgBuf, int msgBufSize)
{
  int rc;

  lock(libMutex);
  rc = libloader(NULL, NULL, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* gamsxGetReady */

/* gamsxGetReadyD: return false on failure to load library, true on success */
static int gamsxGetReadyD (const char *dirName, char *msgBuf, int msgBufSize)
{
  int rc;

  lock(libMutex);
  rc = libloader(dirName, NULL, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* gamsxGetReadyD */

/* gamsxGetReadyL: return false on failure to load library, true on success */
static int gamsxGetReadyL (const char *libName, char *msgBuf, int msgBufSize)
{
  char dirName[1024],fName[1024];
  int rc;

  extractFileDirFileName (libName, dirName, fName);
  lock(libMutex);
  rc = libloader(dirName, fName, msgBuf, msgBufSize);
  unlock(libMutex);
  return rc;
} /* gamsxGetReadyL */

/* gamsxGetReady: return false on failure, true on success */
gamsxBoolean_t F9_CALLCONV
C_GAMSXGETREADY (char **msgBuf, int msgBufSiz)
{
  int gamsxIsReady;
  gamsxIsReady = gamsxGetReady (*msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gamsxIsReady;
} /* gamsxGetReady */

/* gamsxGetReadyD: return false on failure to load library, true on success */
gamsxBoolean_t F9_CALLCONV
C_GAMSXGETREADYD (char **dirName, int dirNameSiz, char **msgBuf, int msgBufSiz)
{
  int gamsxIsReady;
  char dirNameC[512];
  convertF2C (*dirName, dirNameC, dirNameSiz, sizeof(dirNameC));
  **msgBuf = '\0';
  gamsxIsReady = gamsxGetReadyD (dirNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gamsxIsReady;
} /* gamsxGetReadyD */

/* gamsxGetReadyL: return false on failure to load library, true on success */
gamsxBoolean_t F9_CALLCONV
C_GAMSXGETREADYL (char **libName, int libNameSiz, char **msgBuf, int msgBufSiz)
{
  int gamsxIsReady;
  char libNameC[512];
  convertF2C (*libName, libNameC, libNameSiz, sizeof(libNameC));
  **msgBuf = '\0';
  gamsxIsReady = gamsxGetReadyL (libNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gamsxIsReady;
} /* gamsxGetReadyL */

/* gamsxCreate: return false on failure, true on success */
gamsxBoolean_t F9_CALLCONV
C_GAMSXCREATE (u64_t *h, char **msgBuf, int msgBufSiz)
{
  int gamsxIsReady;

  gamsxIsReady = gamsxGetReady (*msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gamsxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(NULL == h->p)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);

  return 1;                     /* return true */
} /* gamsxCreate */

/* gamsxCreateD: return false on failure to load library, true on success */
gamsxBoolean_t F9_CALLCONV
C_GAMSXCREATED (u64_t *h, char **dirName, int dirNameSiz, char **msgBuf, int msgBufSiz)
{
  int gamsxIsReady;
  char dirNameC[512];

  convertF2C (*dirName, dirNameC, dirNameSiz, sizeof(dirNameC));
  **msgBuf = '\0';
  gamsxIsReady = gamsxGetReadyD (dirNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gamsxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(NULL == h->p)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);

  return 1;                     /* return true */
} /* gamsxCreateD */

/* gamsxCreateL: return false on failure to load library, true on success */
gamsxBoolean_t F9_CALLCONV
C_GAMSXCREATEL (u64_t *h, char **libName, int libNameSiz, char **msgBuf, int msgBufSiz)
{
  int gamsxIsReady;
  char libNameC[512];

  convertF2C (*libName, libNameC, libNameSiz, sizeof(libNameC));
  **msgBuf = '\0';
  gamsxIsReady = gamsxGetReadyL (libNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gamsxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(NULL == h->p)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  lock(objMutex);
  objectCount++;
  unlock(objMutex);

  return 1;                     /* return true */
} /* gamsxCreateL */

void F9_CALLCONV
C_GAMSXEXIT (int i)
{
  exit (i);
} /* gamsxExit */

gamsxBoolean_t F9_CALLCONV
C_GAMSXFREE (u64_t *h)
{
  assert(XFree);
  XFree(&(h->p));
  lock(objMutex);
  objectCount--;
  if (isLoaded && 0 == objectCount) {
    (void) unLoadLib (hLibGlobal);
    isLoaded = 0;
  }
  unlock(objMutex);
  return 1;
} /* gamsxFree */

int F9_CALLCONV
C_GAMSXGETSCREENINDICATOR ()
{
  return screenIndicator;
} /* gamsxGetScreenIndicator */

void F9_CALLCONV
C_GAMSXSETSCREENINDICATOR (int scrInd)
{
  screenIndicator = scrInd;
  return;
} /* gamsxSetScreenIndicator */

int F9_CALLCONV
C_GAMSXGETEXITINDICATOR ()
{
  return exitIndicator;
} /* gamsxGetExitIndicator */

void F9_CALLCONV
C_GAMSXSETEXITINDICATOR (int extInd)
{
  exitIndicator = extInd;
  return;
} /* gamsxSetExitIndicator */

void F9_CALLCONV
C_GAMSXSETERRORCALLBACK(errorCallbackFort_t func)
{
  lock(exceptMutex);
  errorCallbackFort = func;
  unlock(exceptMutex);
} /* gamsxSetErrorCallback */

int F9_CALLCONV
C_GAMSXGETAPIERRORCOUNT ()
{
  return APIErrorCount;
} /* gamsxGetAPIErrorCount */


/* start implementation of glue code for functions */

int F9_CALLCONV
C_GAMSXRUNEXECDLL (INT64 iptr_, INT64 optPtr, const char **sysDir, int len_sysDir, int AVerbose, char **Msg, int len_Msg)
{
  u64_t h_;
  int result;
  string255 pas_sysDir;
  string255 pas_Msg;
  u64_t fptr_optPtr;

  h_.i = iptr_;
  convertF2PAS(*sysDir, pas_sysDir, len_sysDir, 255);
  fptr_optPtr.i = optPtr;
  result = gamsxRunExecDLL(h_.p,fptr_optPtr.p,pas_sysDir,AVerbose,pas_Msg);
  convertPAS2F(pas_Msg, *Msg, len_Msg);
  return result;
}

int F9_CALLCONV
C_GAMSXSHOWERROR (INT64 iptr_, const char **fNameLog, int len_fNameLog, char **errorLine, int len_errorLine, char **errorTyp, int len_errorTyp, char **gmsLine, int len_gmsLine)
{
  u64_t h_;
  int result;
  string255 pas_fNameLog;
  string255 pas_errorLine;
  string255 pas_errorTyp;
  string255 pas_gmsLine;

  h_.i = iptr_;
  convertF2PAS(*fNameLog, pas_fNameLog, len_fNameLog, 255);
  result = gamsxShowError(h_.p,pas_fNameLog,pas_errorLine,pas_errorTyp,pas_gmsLine);
  convertPAS2F(pas_errorLine, *errorLine, len_errorLine);
  convertPAS2F(pas_errorTyp, *errorTyp, len_errorTyp);
  convertPAS2F(pas_gmsLine, *gmsLine, len_gmsLine);
  return result;
}

void F9_CALLCONV
C_GAMSXADDBREAKPOINT (INT64 iptr_, const char **fn, int len_fn, int lineNr)
{
  u64_t h_;
  string255 pas_fn;

  h_.i = iptr_;
  convertF2PAS(*fn, pas_fn, len_fn, 255);
  gamsxAddBreakPoint(h_.p,pas_fn,lineNr);
}

void F9_CALLCONV
C_GAMSXCLEARBREAKPOINTS (INT64 iptr_)
{
  u64_t h_;

  h_.i = iptr_;
  gamsxClearBreakPoints(h_.p);
}

int F9_CALLCONV
C_GAMSXSYSTEMINFO (INT64 iptr_, int *NrSy, int *NrUel)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gamsxSystemInfo(h_.p,NrSy,NrUel);
  return result;
}

int F9_CALLCONV
C_GAMSXSYMBOLINFO (INT64 iptr_, int SyNr, char **SyName, int len_SyName, char **SyExplTxt, int len_SyExplTxt, int *SyDim, int *SyTyp, int *SyCount, int *SyUserInfo)
{
  u64_t h_;
  int result;
  string255 pas_SyName;
  string255 pas_SyExplTxt;

  h_.i = iptr_;
  result = gamsxSymbolInfo(h_.p,SyNr,pas_SyName,pas_SyExplTxt,SyDim,SyTyp,SyCount,SyUserInfo);
  convertPAS2F(pas_SyName, *SyName, len_SyName);
  convertPAS2F(pas_SyExplTxt, *SyExplTxt, len_SyExplTxt);
  return result;
}

void F9_CALLCONV
C_GAMSXUELNAME (char *S, int SLEN, INT64 iptr_, int uel)
{
  u64_t h_;
  string255 pas_buf;

  h_.i = iptr_;
  gamsxUelName(h_.p,uel,pas_buf);
  convertPAS2F (pas_buf, S, SLEN);
  return;
}

int F9_CALLCONV
C_GAMSXFINDSYMBOL (INT64 iptr_, const char **SyName, int len_SyName)
{
  u64_t h_;
  int result;
  string255 pas_SyName;

  h_.i = iptr_;
  convertF2PAS(*SyName, pas_SyName, len_SyName, 255);
  result = gamsxFindSymbol(h_.p,pas_SyName);
  return result;
}

int F9_CALLCONV
C_GAMSXDATAREADRAWSTART (INT64 iptr_, int SyNr, int *SyCount)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gamsxDataReadRawStart(h_.p,SyNr,SyCount);
  return result;
}

int F9_CALLCONV
C_GAMSXDATAREADRAW (INT64 iptr_, int Elements[], double Vals[], int *FDim)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gamsxDataReadRaw(h_.p,Elements,Vals,FDim);
  return result;
}

int F9_CALLCONV
C_GAMSXDATAREADDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gamsxDataReadDone(h_.p);
  return result;
}

int F9_CALLCONV
C_GAMSXDATAWRITERAWSTART (INT64 iptr_, int SyNr, int DoMerge)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gamsxDataWriteRawStart(h_.p,SyNr,DoMerge);
  return result;
}

int F9_CALLCONV
C_GAMSXDATAWRITERAW (INT64 iptr_, const int Elements[], const double Vals[])
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gamsxDataWriteRaw(h_.p,Elements,Vals);
  return result;
}

int F9_CALLCONV
C_GAMSXDATAWRITEDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gamsxDataWriteDone(h_.p);
  return result;
}

void F9_CALLCONV
C_GAMSXREGISTERCB1 (INT64 iptr_, TBrkPCallBack1_F_t CB1, INT64 userMem)
{
  u64_t h_;
  u64_t fptr_userMem;

  h_.i = iptr_;
  fptr_userMem.i = userMem;
  gamsxRegisterCB1(h_.p,CB1,fptr_userMem.p);
}

void F9_CALLCONV
C_GAMSXREGISTERCB2 (INT64 iptr_, TBrkPCallBack2_F_t CB2, INT64 userMem1, INT64 userMem2)
{
  u64_t h_;
  u64_t fptr_userMem1;
  u64_t fptr_userMem2;

  h_.i = iptr_;
  fptr_userMem1.i = userMem1;
  fptr_userMem2.i = userMem2;
  gamsxRegisterCB2(h_.p,CB2,fptr_userMem1.p,fptr_userMem2.p);
}

INT64 F9_CALLCONV
C_GAMSXGETCB1 (INT64 iptr_)
{
  u64_t h_;
  u64TBrkPCallBack1_t result;
  h_.i = iptr_;
  result.i = 0;
  result.f = gamsxGetCB1(h_.p);
  return result.i;
}

INT64 F9_CALLCONV
C_GAMSXGETCB2 (INT64 iptr_)
{
  u64_t h_;
  u64TBrkPCallBack2_t result;
  h_.i = iptr_;
  result.i = 0;
  result.f = gamsxGetCB2(h_.p);
  return result.i;
}

INT64 F9_CALLCONV
C_GAMSXGETCB1UM (INT64 iptr_)
{
  u64_t h_;
  u64_t result;

  h_.i = iptr_;
  result.i = 0;
  result.p = gamsxGetCB1UM(h_.p);
  return result.i;
}

INT64 F9_CALLCONV
C_GAMSXGETCB2UM1 (INT64 iptr_)
{
  u64_t h_;
  u64_t result;

  h_.i = iptr_;
  result.i = 0;
  result.p = gamsxGetCB2UM1(h_.p);
  return result.i;
}

INT64 F9_CALLCONV
C_GAMSXGETCB2UM2 (INT64 iptr_)
{
  u64_t h_;
  u64_t result;

  h_.i = iptr_;
  result.i = 0;
  result.p = gamsxGetCB2UM2(h_.p);
  return result.i;
}

/* start implementation of glue code for properties */

void F9_CALLCONV
C_GAMSXSWSET (INT64 iptr, int x)
{
  u64_t h;

  h.i = iptr;
  gamsxSWSet(h.p,x);
}

int F9_CALLCONV
C_GAMSXSTEPTHROUGH (INT64 iptr)
{
  u64_t h;

  h.i = iptr;
  return gamsxStepThrough(h.p);
}

void F9_CALLCONV
C_GAMSXSTEPTHROUGHSET (INT64 iptr, int x)
{
  u64_t h;

  h.i = iptr;
  gamsxStepThroughSet(h.p,x);
}

int F9_CALLCONV
C_GAMSXRUNTOEND (INT64 iptr)
{
  u64_t h;

  h.i = iptr;
  return gamsxRunToEnd(h.p);
}

void F9_CALLCONV
C_GAMSXRUNTOENDSET (INT64 iptr, int x)
{
  u64_t h;

  h.i = iptr;
  gamsxRunToEndSet(h.p,x);
}

int F9_CALLCONV
C_GAMSXCB1DEFINED (INT64 iptr)
{
  u64_t h;

  h.i = iptr;
  return gamsxCB1Defined(h.p);
}

int F9_CALLCONV
C_GAMSXCB2DEFINED (INT64 iptr)
{
  u64_t h;

  h.i = iptr;
  return gamsxCB2Defined(h.p);
}

