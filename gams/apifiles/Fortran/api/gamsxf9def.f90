MODULE gamsxf9def

  ! F90 procedure wrapper generated by apiwrapper for GAMS Version 24.0.2

  IMPLICIT NONE

  ! Constant declarations


  ! procedure interfaces
  ! Some compilers (e.g. ifc 7.1) cannot handle these as module subroutines

  INTERFACE
     SUBROUTINE  gamsxAddBreakPoint(pgamsx,fn,lineNr)
       INTEGER(KIND=8), INTENT(IN) :: pgamsx
       CHARACTER(LEN=*), INTENT(IN) :: fn
       INTEGER(KIND=4), INTENT(IN) :: lineNr
     END SUBROUTINE gamsxAddBreakPoint
  END INTERFACE

  INTERFACE
     SUBROUTINE  gamsxClearBreakPoints(pgamsx)
       INTEGER(KIND=8), INTENT(IN) :: pgamsx
     END SUBROUTINE gamsxClearBreakPoints
  END INTERFACE

  INTERFACE
     SUBROUTINE  gamsxRegisterCB1(pgamsx,CB1,userMem)
       INTEGER(KIND=8), INTENT(IN) :: pgamsx
       INTEGER(KIND=4), EXTERNAL :: CB1
       INTEGER(KIND=8), INTENT(IN) :: userMem
     END SUBROUTINE gamsxRegisterCB1
  END INTERFACE

  INTERFACE
     SUBROUTINE  gamsxRegisterCB2(pgamsx,CB2,userMem1,userMem2)
       INTEGER(KIND=8), INTENT(IN) :: pgamsx
       INTEGER(KIND=4), EXTERNAL :: CB2
       INTEGER(KIND=8), INTENT(IN) :: userMem1
       INTEGER(KIND=8), INTENT(IN) :: userMem2
     END SUBROUTINE gamsxRegisterCB2
  END INTERFACE


  ! procedure interfaces for properties
  ! Some compilers (e.g. ifc 7.1) cannot handle these as module subroutines

  INTERFACE
     SUBROUTINE gamsxSWSet(pgamsx,x)
       INTEGER(KIND=8), INTENT(IN) :: pgamsx
       INTEGER(KIND=4), INTENT(IN) :: x
     END SUBROUTINE gamsxSWSet
  END INTERFACE

  INTERFACE
     SUBROUTINE gamsxStepThroughSet(pgamsx,x)
       INTEGER(KIND=8), INTENT(IN) :: pgamsx
       LOGICAL, INTENT(IN) :: x
     END SUBROUTINE gamsxStepThroughSet
  END INTERFACE

  INTERFACE
     SUBROUTINE gamsxRunToEndSet(pgamsx,x)
       INTEGER(KIND=8), INTENT(IN) :: pgamsx
       LOGICAL, INTENT(IN) :: x
     END SUBROUTINE gamsxRunToEndSet
  END INTERFACE



CONTAINS


  LOGICAL FUNCTION gamsxCreate(pgamsx, errMsg)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxCreate
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxCreate
    INTEGER(KIND=8), INTENT(OUT) :: pgamsx
    CHARACTER(LEN=*), INTENT(OUT) :: errMsg
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxCreate

    gamsxCreate = c_gamsxCreate(pgamsx, loc(errMsg), %val(len(errMsg)))
  END FUNCTION gamsxCreate

  LOGICAL FUNCTION gamsxCreateD(pgamsx, dirName, errMsg)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxCreateD
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxCreateD
    INTEGER(KIND=8), INTENT(OUT) :: pgamsx
    CHARACTER(LEN=*), INTENT(IN) :: dirName
    CHARACTER(LEN=*), INTENT(OUT) :: errMsg
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxCreateD

    gamsxCreateD = c_gamsxCreateD(pgamsx, loc(dirName), %val(len(dirName)), &
         loc(errMsg), %val(len(errMsg)))
  END FUNCTION gamsxCreateD

  LOGICAL FUNCTION gamsxCreateL(pgamsx, libName, errMsg)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxCreateL
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxCreateL
    INTEGER(KIND=8), INTENT(OUT) :: pgamsx
    CHARACTER(LEN=*), INTENT(IN) :: libName
    CHARACTER(LEN=*), INTENT(OUT) :: errMsg
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxCreateL

    gamsxCreateL = c_gamsxCreateL(pgamsx, loc(libName), %val(len(libName)), &
         loc(errMsg), %val(len(errMsg)))
  END FUNCTION gamsxCreateL

  LOGICAL FUNCTION gamsxGetReady(errMsg)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetReady
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetReady
    CHARACTER(LEN=*), INTENT(OUT) :: errMsg
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxGetReady

    gamsxGetReady = c_gamsxGetReady(loc(errMsg), %val(len(errMsg)))
  END FUNCTION gamsxGetReady

  LOGICAL FUNCTION gamsxGetReadyD(dirName, errMsg)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetReadyD
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetReadyD
    CHARACTER(LEN=*), INTENT(IN) :: dirName
    CHARACTER(LEN=*), INTENT(OUT) :: errMsg
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxGetReadyD

    gamsxGetReadyD = c_gamsxGetReadyD(loc(dirName), %val(len(dirName)), &
         loc(errMsg), %val(len(errMsg)))
  END FUNCTION gamsxGetReadyD

  LOGICAL FUNCTION gamsxGetReadyL(libName, errMsg)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetReadyL
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetReadyL
    CHARACTER(LEN=*), INTENT(IN) :: libName
    CHARACTER(LEN=*), INTENT(OUT) :: errMsg
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxGetReadyL

    gamsxGetReadyL = c_gamsxGetReadyL(loc(libName), %val(len(libName)), &
         loc(errMsg), %val(len(errMsg)))
  END FUNCTION gamsxGetReadyL

  SUBROUTINE gamsxExit(i)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxExit
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxExit
    INTEGER(KIND=4), INTENT(IN) :: i

    CALL c_gamsxExit(%val(i))
  END SUBROUTINE gamsxExit

  LOGICAL FUNCTION gamsxFree(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxFree
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxFree
    INTEGER(KIND=8), INTENT(OUT) :: pgamsx
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxFree

    gamsxFree = c_gamsxFree(pgamsx)
  END FUNCTION gamsxFree

  LOGICAL FUNCTION gamsxGetScreenIndicator()
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetScreenIndicator
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetScreenIndicator
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxGetScreenIndicator

    gamsxGetScreenIndicator = c_gamsxGetScreenIndicator()
  END FUNCTION gamsxGetScreenIndicator

  SUBROUTINE gamsxSetScreenIndicator(scrInd)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxSetScreenIndicator
    INTEGER(KIND=4), INTENT(IN) :: scrInd
    EXTERNAL c_gamsxSetScreenIndicator

    CALL c_gamsxSetScreenIndicator(%val(scrInd))
  END SUBROUTINE gamsxSetScreenIndicator

  LOGICAL FUNCTION gamsxGetExitIndicator()
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetExitIndicator
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetExitIndicator
    LOGICAL(KIND=4), EXTERNAL :: c_gamsxGetExitIndicator

    gamsxGetExitIndicator = c_gamsxGetExitIndicator()
  END FUNCTION gamsxGetExitIndicator

  SUBROUTINE gamsxSetExitIndicator(extInd)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxSetExitIndicator
    INTEGER(KIND=4), INTENT(IN) :: extInd
    EXTERNAL c_gamsxSetExitIndicator

    CALL c_gamsxSetExitIndicator(%val(extInd))
  END SUBROUTINE gamsxSetExitIndicator

  SUBROUTINE gamsxSetErrorCallback(cbFunc)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxSetErrorCallback
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxSetErrorCallback
    INTEGER(KIND=4), EXTERNAL :: cbFunc

    CALL c_gamsxSetErrorCallback(cbFunc)
  END SUBROUTINE gamsxSetErrorCallback

  INTEGER FUNCTION gamsxGetAPIErrorCount()
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetAPIErrorCount
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetAPIErrorCount
   INTEGER(KIND=4), EXTERNAL :: c_gamsxGetAPIErrorCount

    gamsxGetAPIErrorCount = c_gamsxGetAPIErrorCount()
  END FUNCTION gamsxGetAPIErrorCount


  INTEGER(KIND=4) FUNCTION gamsxRunExecDLL(pgamsx,optPtr,sysDir,AVerbose, &
         Msg)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxRunExecDLL
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxRunExecDLL
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=8), INTENT(IN) :: optPtr
    CHARACTER(LEN=*), INTENT(IN) :: sysDir
    INTEGER(KIND=4), INTENT(IN) :: AVerbose
    CHARACTER(LEN=*), INTENT(OUT) :: Msg
    INTEGER(KIND=4), EXTERNAL :: c_gamsxRunExecDLL

    gamsxRunExecDLL=c_gamsxRunExecDLL(%val(pgamsx),%val(optPtr),loc(sysDir),%val(len(sysDir)), &
         %val(AVerbose),loc(Msg),%val(len(Msg)))
  END FUNCTION gamsxRunExecDLL

  LOGICAL FUNCTION gamsxShowError(pgamsx,fNameLog,errorLine,errorTyp, &
         gmsLine)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxShowError
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxShowError
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    CHARACTER(LEN=*), INTENT(IN) :: fNameLog
    CHARACTER(LEN=*), INTENT(OUT) :: errorLine
    CHARACTER(LEN=*), INTENT(OUT) :: errorTyp
    CHARACTER(LEN=*), INTENT(OUT) :: gmsLine
    INTEGER(KIND=4), EXTERNAL :: c_gamsxShowError

    gamsxShowError=c_gamsxShowError(%val(pgamsx),loc(fNameLog),%val(len(fNameLog)), &
         loc(errorLine),%val(len(errorLine)),loc(errorTyp),%val(len(errorTyp)), &
         loc(gmsLine),%val(len(gmsLine))) /= 0
  END FUNCTION gamsxShowError

  INTEGER(KIND=4) FUNCTION gamsxSystemInfo(pgamsx,NrSy,NrUel)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxSystemInfo
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxSystemInfo
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), INTENT(IN OUT) :: NrSy
    INTEGER(KIND=4), INTENT(IN OUT) :: NrUel
    INTEGER(KIND=4), EXTERNAL :: c_gamsxSystemInfo

    gamsxSystemInfo=c_gamsxSystemInfo(%val(pgamsx),NrSy,NrUel)
  END FUNCTION gamsxSystemInfo

  INTEGER(KIND=4) FUNCTION gamsxSymbolInfo(pgamsx,SyNr,SyName,SyExplTxt, &
         SyDim,SyTyp,SyCount,SyUserInfo)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxSymbolInfo
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxSymbolInfo
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), INTENT(IN) :: SyNr
    CHARACTER(LEN=*), INTENT(OUT) :: SyName
    CHARACTER(LEN=*), INTENT(OUT) :: SyExplTxt
    INTEGER(KIND=4), INTENT(IN OUT) :: SyDim
    INTEGER(KIND=4), INTENT(IN OUT) :: SyTyp
    INTEGER(KIND=4), INTENT(IN OUT) :: SyCount
    INTEGER(KIND=4), INTENT(IN OUT) :: SyUserInfo
    INTEGER(KIND=4), EXTERNAL :: c_gamsxSymbolInfo

    gamsxSymbolInfo=c_gamsxSymbolInfo(%val(pgamsx),%val(SyNr),loc(SyName),%val(len(SyName)), &
         loc(SyExplTxt),%val(len(SyExplTxt)),SyDim,SyTyp,SyCount, &
         SyUserInfo)
  END FUNCTION gamsxSymbolInfo

  CHARACTER(LEN=255) FUNCTION gamsxUelName(pgamsx,uel)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxUelName
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxUelName
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), INTENT(IN) :: uel
    CHARACTER(LEN=255), EXTERNAL :: c_gamsxUelName

    gamsxUelName=c_gamsxUelName(%val(pgamsx),%val(uel))
  END FUNCTION gamsxUelName

  INTEGER(KIND=4) FUNCTION gamsxFindSymbol(pgamsx,SyName)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxFindSymbol
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxFindSymbol
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    CHARACTER(LEN=*), INTENT(IN) :: SyName
    INTEGER(KIND=4), EXTERNAL :: c_gamsxFindSymbol

    gamsxFindSymbol=c_gamsxFindSymbol(%val(pgamsx),loc(SyName),%val(len(SyName)))
  END FUNCTION gamsxFindSymbol

  INTEGER(KIND=4) FUNCTION gamsxDataReadRawStart(pgamsx,SyNr,SyCount)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxDataReadRawStart
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxDataReadRawStart
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), INTENT(IN) :: SyNr
    INTEGER(KIND=4), INTENT(IN OUT) :: SyCount
    INTEGER(KIND=4), EXTERNAL :: c_gamsxDataReadRawStart

    gamsxDataReadRawStart=c_gamsxDataReadRawStart(%val(pgamsx),%val(SyNr), &
         SyCount)
  END FUNCTION gamsxDataReadRawStart

  INTEGER(KIND=4) FUNCTION gamsxDataReadRaw(pgamsx,Elements,Vals, &
         FDim)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxDataReadRaw
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxDataReadRaw
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), DIMENSION(*), INTENT(IN OUT) :: Elements
    REAL(KIND=8), DIMENSION(*), INTENT(IN OUT) :: Vals
    INTEGER(KIND=4), INTENT(IN OUT) :: FDim
    INTEGER(KIND=4), EXTERNAL :: c_gamsxDataReadRaw

    gamsxDataReadRaw=c_gamsxDataReadRaw(%val(pgamsx),Elements,Vals, &
         FDim)
  END FUNCTION gamsxDataReadRaw

  INTEGER(KIND=4) FUNCTION gamsxDataReadDone(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxDataReadDone
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxDataReadDone
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), EXTERNAL :: c_gamsxDataReadDone

    gamsxDataReadDone=c_gamsxDataReadDone(%val(pgamsx))
  END FUNCTION gamsxDataReadDone

  INTEGER(KIND=4) FUNCTION gamsxDataWriteRawStart(pgamsx,SyNr,DoMerge)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxDataWriteRawStart
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxDataWriteRawStart
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), INTENT(IN) :: SyNr
    LOGICAL, INTENT(IN) :: DoMerge
    INTEGER(KIND=4) :: ib_DoMerge
    INTEGER(KIND=4), EXTERNAL :: c_gamsxDataWriteRawStart

    ib_DoMerge = 0
    IF (DoMerge) ib_DoMerge = 1
    gamsxDataWriteRawStart=c_gamsxDataWriteRawStart(%val(pgamsx), &
         %val(SyNr),%val(ib_DoMerge))
  END FUNCTION gamsxDataWriteRawStart

  INTEGER(KIND=4) FUNCTION gamsxDataWriteRaw(pgamsx,Elements,Vals)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxDataWriteRaw
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxDataWriteRaw
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), DIMENSION(*), INTENT(IN) :: Elements
    REAL(KIND=8), DIMENSION(*), INTENT(IN) :: Vals
    INTEGER(KIND=4), EXTERNAL :: c_gamsxDataWriteRaw

    gamsxDataWriteRaw=c_gamsxDataWriteRaw(%val(pgamsx),Elements,Vals)
  END FUNCTION gamsxDataWriteRaw

  INTEGER(KIND=4) FUNCTION gamsxDataWriteDone(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxDataWriteDone
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxDataWriteDone
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), EXTERNAL :: c_gamsxDataWriteDone

    gamsxDataWriteDone=c_gamsxDataWriteDone(%val(pgamsx))
  END FUNCTION gamsxDataWriteDone

  INTEGER(KIND=8) FUNCTION gamsxGetCB1(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetCB1
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetCB1
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=8), EXTERNAL :: c_gamsxGetCB1

    gamsxGetCB1=c_gamsxGetCB1(%val(pgamsx))
  END FUNCTION gamsxGetCB1

  INTEGER(KIND=8) FUNCTION gamsxGetCB2(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetCB2
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetCB2
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=8), EXTERNAL :: c_gamsxGetCB2

    gamsxGetCB2=c_gamsxGetCB2(%val(pgamsx))
  END FUNCTION gamsxGetCB2

  INTEGER(KIND=8) FUNCTION gamsxGetCB1UM(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetCB1UM
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetCB1UM
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=8), EXTERNAL :: c_gamsxGetCB1UM

    gamsxGetCB1UM=c_gamsxGetCB1UM(%val(pgamsx))
  END FUNCTION gamsxGetCB1UM

  INTEGER(KIND=8) FUNCTION gamsxGetCB2UM1(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetCB2UM1
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetCB2UM1
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=8), EXTERNAL :: c_gamsxGetCB2UM1

    gamsxGetCB2UM1=c_gamsxGetCB2UM1(%val(pgamsx))
  END FUNCTION gamsxGetCB2UM1

  INTEGER(KIND=8) FUNCTION gamsxGetCB2UM2(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxGetCB2UM2
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxGetCB2UM2
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=8), EXTERNAL :: c_gamsxGetCB2UM2

    gamsxGetCB2UM2=c_gamsxGetCB2UM2(%val(pgamsx))
  END FUNCTION gamsxGetCB2UM2

  ! properties

  LOGICAL FUNCTION gamsxStepThrough(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxStepThrough
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxStepThrough
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), EXTERNAL :: c_gamsxStepThrough

    gamsxStepThrough=c_gamsxStepThrough(%val(pgamsx)) /= 0
  END FUNCTION gamsxStepThrough

  LOGICAL FUNCTION gamsxRunToEnd(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxRunToEnd
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxRunToEnd
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), EXTERNAL :: c_gamsxRunToEnd

    gamsxRunToEnd=c_gamsxRunToEnd(%val(pgamsx)) /= 0
  END FUNCTION gamsxRunToEnd

  LOGICAL FUNCTION gamsxCB1Defined(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxCB1Defined
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxCB1Defined
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), EXTERNAL :: c_gamsxCB1Defined

    gamsxCB1Defined=c_gamsxCB1Defined(%val(pgamsx)) /= 0
  END FUNCTION gamsxCB1Defined

  LOGICAL FUNCTION gamsxCB2Defined(pgamsx)
    !DEC$ ATTRIBUTES STDCALL :: c_gamsxCB2Defined
    !DEC$ ATTRIBUTES REFERENCE :: c_gamsxCB2Defined
    INTEGER(KIND=8), INTENT(IN) :: pgamsx
    INTEGER(KIND=4), EXTERNAL :: c_gamsxCB2Defined

    gamsxCB2Defined=c_gamsxCB2Defined(%val(pgamsx)) /= 0
  END FUNCTION gamsxCB2Defined


END MODULE gamsxf9def



! external subroutine
! Some compilers (e.g. ifc 7.1) cannot handle these as module subroutines

SUBROUTINE gamsxAddBreakPoint(pgamsx,fn,lineNr)
  !DEC$ ATTRIBUTES STDCALL :: c_gamsxAddBreakPoint
  !DEC$ ATTRIBUTES REFERENCE :: c_gamsxAddBreakPoint
  INTEGER(KIND=8), INTENT(IN) :: pgamsx
  CHARACTER(LEN=*), INTENT(IN) :: fn
  INTEGER(KIND=4), INTENT(IN) :: lineNr
  EXTERNAL c_gamsxAddBreakPoint

  CALL c_gamsxAddBreakPoint(%val(pgamsx),loc(fn),%val(len(fn)),%val(lineNr))
END SUBROUTINE gamsxAddBreakPoint

SUBROUTINE gamsxClearBreakPoints(pgamsx)
  !DEC$ ATTRIBUTES STDCALL :: c_gamsxClearBreakPoints
  !DEC$ ATTRIBUTES REFERENCE :: c_gamsxClearBreakPoints
  INTEGER(KIND=8), INTENT(IN) :: pgamsx
  EXTERNAL c_gamsxClearBreakPoints

  CALL c_gamsxClearBreakPoints(%val(pgamsx))
END SUBROUTINE gamsxClearBreakPoints

SUBROUTINE gamsxRegisterCB1(pgamsx,CB1,userMem)
  !DEC$ ATTRIBUTES STDCALL :: c_gamsxRegisterCB1
  !DEC$ ATTRIBUTES REFERENCE :: c_gamsxRegisterCB1
  INTEGER(KIND=8), INTENT(IN) :: pgamsx
  INTEGER(KIND=4), EXTERNAL :: CB1
  INTEGER(KIND=8), INTENT(IN) :: userMem
  EXTERNAL c_gamsxRegisterCB1

  CALL c_gamsxRegisterCB1(%val(pgamsx),CB1,%val(userMem))
END SUBROUTINE gamsxRegisterCB1

SUBROUTINE gamsxRegisterCB2(pgamsx,CB2,userMem1,userMem2)
  !DEC$ ATTRIBUTES STDCALL :: c_gamsxRegisterCB2
  !DEC$ ATTRIBUTES REFERENCE :: c_gamsxRegisterCB2
  INTEGER(KIND=8), INTENT(IN) :: pgamsx
  INTEGER(KIND=4), EXTERNAL :: CB2
  INTEGER(KIND=8), INTENT(IN) :: userMem1
  INTEGER(KIND=8), INTENT(IN) :: userMem2
  EXTERNAL c_gamsxRegisterCB2

  CALL c_gamsxRegisterCB2(%val(pgamsx),CB2,%val(userMem1),%val(userMem2))
END SUBROUTINE gamsxRegisterCB2


! external subroutines for properties
! Some compilers (e.g. ifc 7.1) cannot handle these as module subroutines


SUBROUTINE gamsxSWSet(pgamsx,x)
  !DEC$ ATTRIBUTES STDCALL :: c_gamsxSWSet
  !DEC$ ATTRIBUTES REFERENCE :: c_gamsxSWSet
  INTEGER(KIND=8), INTENT(IN) :: pgamsx
  INTEGER(KIND=4), INTENT(IN) :: x
  EXTERNAL c_gamsxSWSet

  CALL c_gamsxSWSet(%val(pgamsx),%val(x))
END SUBROUTINE gamsxSWSet

SUBROUTINE gamsxStepThroughSet(pgamsx,x)
  !DEC$ ATTRIBUTES STDCALL :: c_gamsxStepThroughSet
  !DEC$ ATTRIBUTES REFERENCE :: c_gamsxStepThroughSet
  INTEGER(KIND=8), INTENT(IN) :: pgamsx
  LOGICAL, INTENT(IN) :: x
  INTEGER(KIND=4) :: ib_x
  EXTERNAL c_gamsxStepThroughSet

  ib_x = 0
  IF (x) ib_x = 1
  CALL c_gamsxStepThroughSet(%val(pgamsx),%val(ib_x))
END SUBROUTINE gamsxStepThroughSet

SUBROUTINE gamsxRunToEndSet(pgamsx,x)
  !DEC$ ATTRIBUTES STDCALL :: c_gamsxRunToEndSet
  !DEC$ ATTRIBUTES REFERENCE :: c_gamsxRunToEndSet
  INTEGER(KIND=8), INTENT(IN) :: pgamsx
  LOGICAL, INTENT(IN) :: x
  INTEGER(KIND=4) :: ib_x
  EXTERNAL c_gamsxRunToEndSet

  ib_x = 0
  IF (x) ib_x = 1
  CALL c_gamsxRunToEndSet(%val(pgamsx),%val(ib_x))
END SUBROUTINE gamsxRunToEndSet
