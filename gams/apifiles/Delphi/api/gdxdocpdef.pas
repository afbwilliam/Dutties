unit gdxdocpdef; { Delphi object wrapper generated by apiwrapper for GAMS Version 24.0.2 }
{ Object interface using a DLL, pure Delphi }

{$H- short only }
{$P- no open parameters ==> no maxlen byte}
{$V+ force var strings}

interface

uses
   sysutils,
   gmsgen,
   gxdefs;


//tries to load DLL from OS default location
//name for the DLL is automatic
function  gdxGetReady(var Msg: ShortString): boolean;
//tries to load DLL from main program directory; if that fails
//loads DLL from OS default location
//name for the DLL is automatic
function  gdxGetReadyX(var Msg: ShortString): boolean;
//loads DLL from specified directory
//name for the DLL is automatic
function  gdxGetReadyD(const Dir: ShortString; var Msg: ShortString): boolean;
//loads DLL from the full path specified
//no changes are made to the name (platform and file extension)
function  gdxGetReadyL(const LibName: ShortString; var Msg: ShortString): boolean;

procedure gdxSetLoadPath(const s: shortString);
procedure gdxGetLoadPath(var s: shortString);

procedure gdxLibraryUnload;
function  gdxLibraryLoaded: boolean;


type
   TErrorCallback  = function(ErrCount:Integer; const Msg:ShortString):Integer; stdcall;
   PTErrorCallBack = ^TErrorCallBack;
   TDataStoreProc  = procedure(const Indx: TgdxUELIndex; const Vals: TgdxValues); stdcall;
   PTDataStoreProc = ^TDataStoreProc;

   TGXFile = Class
   private
      pgdx  : pointer;
      own   : boolean;

   public
      constructor Create          (var Msg: ShortString);
      constructor CreateX         (var Msg: ShortString);
      constructor CreateD         (const Dir: ShortString; var Msg: ShortString);
      constructor CreateL         (const LibName: ShortString; var Msg: ShortString);
      constructor CreateWithHandle(p: pointer; var Msg: ShortString);
      destructor  Destroy         ; override; { always use free and never destroy }

      function  gdxGetHandle            : pointer;
      function  gdxGetScreenIndicator   : boolean;
      procedure gdxSetScreenIndicator   (const ScrInd: boolean);
      function  gdxGetExceptionIndicator: boolean;
      procedure gdxSetExceptionIndicator(const ExcInd: boolean);
      function  gdxGetExitIndicator     : boolean;
      procedure gdxSetExitIndicator     (const ExtInd: boolean);
      function  gdxGetErrorCallback     : PTErrorCallback;
      procedure gdxSetErrorCallback     (ecb: PTErrorCallback);
      function  gdxGetErrorCount        : Integer;
      procedure gdxSetErrorCount        (const ecnt: Integer);

      function  gdxAcronymAdd           (const AName: ShortString; const Txt: ShortString; AIndx: Integer): Integer;
      function  gdxAcronymCount         : Integer;
      function  gdxAcronymGetInfo       (N: Integer; var{out} AName: ShortString; var{out} Txt: ShortString; var{out} AIndx: Integer): Integer;
      function  gdxAcronymGetMapping    (N: Integer; var{out} orgIndx: Integer; var{out} newIndx: Integer; var{out} autoIndex: Integer): Integer;
      function  gdxAcronymIndex         (V: Double): Integer;
      function  gdxAcronymName          (V: Double; var{out} AName: ShortString): Integer;
      function  gdxAcronymNextNr        (NV: Integer): Integer;
      function  gdxAcronymSetInfo       (N: Integer; const AName: ShortString; const Txt: ShortString; AIndx: Integer): Integer;
      function  gdxAcronymValue         (AIndx: Integer): Double;
      function  gdxAddAlias             (const Id1: ShortString; const Id2: ShortString): Integer;
      function  gdxAddSetText           (const Txt: ShortString; var{out} TxtNr: Integer): Integer;
      function  gdxAutoConvert          (NV: Integer): Integer;
      function  gdxClose                : Integer;
      function  gdxDataErrorCount       : Integer;
      function  gdxDataErrorRecord      (RecNr: Integer; var KeyInt: TgdxUELIndex; var Values: TgdxValues): Integer;
      function  gdxDataReadDone         : Integer;
      function  gdxDataReadFilteredStart(SyNr: Integer; const FilterAction: TgdxUELIndex; var{out} NrRecs: Integer): Integer;
      function  gdxDataReadMap          (RecNr: Integer; var KeyInt: TgdxUELIndex; var Values: TgdxValues; var{out} DimFrst: Integer): Integer;
      function  gdxDataReadMapStart     (SyNr: Integer; var{out} NrRecs: Integer): Integer;
      function  gdxDataReadRaw          (var KeyInt: TgdxUELIndex; var Values: TgdxValues; var{out} DimFrst: Integer): Integer;
      function  gdxDataReadRawFast      (SyNr: Integer; DP: TDataStoreProc; var{out} NrRecs: Integer): Integer;
      function  gdxDataReadRawStart     (SyNr: Integer; var{out} NrRecs: Integer): Integer;
      function  gdxDataReadSlice        (const UelFilterStr: TgdxStrIndex; var{out} Dimen: Integer; DP: TDataStoreProc): Integer;
      function  gdxDataReadSliceStart   (SyNr: Integer; var ElemCounts: TgdxUELIndex): Integer;
      function  gdxDataReadStr          (var{out} KeyStr: TgdxStrIndex; var Values: TgdxValues; var{out} DimFrst: Integer): Integer;
      function  gdxDataReadStrStart     (SyNr: Integer; var{out} NrRecs: Integer): Integer;
      function  gdxDataSliceUELS        (const SliceKeyInt: TgdxUELIndex; var{out} KeyStr: TgdxStrIndex): Integer;
      function  gdxDataWriteDone        : Integer;
      function  gdxDataWriteMap         (const KeyInt: TgdxUELIndex; const Values: TgdxValues): Integer;
      function  gdxDataWriteMapStart    (const SyId: ShortString; const ExplTxt: ShortString; Dimen: Integer; Typ: Integer; UserInfo: Integer): Integer;
      function  gdxDataWriteRaw         (const KeyInt: TgdxUELIndex; const Values: TgdxValues): Integer;
      function  gdxDataWriteRawStart    (const SyId: ShortString; const ExplTxt: ShortString; Dimen: Integer; Typ: Integer; UserInfo: Integer): Integer;
      function  gdxDataWriteStr         (const KeyStr: TgdxStrIndex; const Values: TgdxValues): Integer;
      function  gdxDataWriteStrStart    (const SyId: ShortString; const ExplTxt: ShortString; Dimen: Integer; Typ: Integer; UserInfo: Integer): Integer;
      function  gdxGetDLLVersion        (var{out} V: ShortString): Integer;
      function  gdxErrorCount           : Integer;
      function  gdxErrorStr             (ErrNr: Integer; var{out} ErrMsg: ShortString): Integer;
      function  gdxFileInfo             (var{out} FileVer: Integer; var{out} ComprLev: Integer): Integer;
      function  gdxFileVersion          (var{out} FileStr: ShortString; var{out} ProduceStr: ShortString): Integer;
      function  gdxFilterExists         (FilterNr: Integer): Integer;
      function  gdxFilterRegister       (UelMap: Integer): Integer;
      function  gdxFilterRegisterDone   : Integer;
      function  gdxFilterRegisterStart  (FilterNr: Integer): Integer;
      function  gdxFindSymbol           (const SyId: ShortString; var{out} SyNr: Integer): Integer;
      function  gdxGetElemText          (TxtNr: Integer; var{out} Txt: ShortString; var{out} Node: Integer): Integer;
      function  gdxGetLastError         : Integer;
      function  gdxGetMemoryUsed        : Int64;
      function  gdxGetSpecialValues     (var AVals: TgdxSVals): Integer;
      function  gdxGetUEL               (UelNr: Integer; var{out} Uel: ShortString): Integer;
      function  gdxMapValue             (D: Double; var{out} sv: Integer): Integer;
      function  gdxOpenAppend           (const FileName: ShortString; const Producer: ShortString; var{out} ErrNr: Integer): Integer;
      function  gdxOpenRead             (const FileName: ShortString; var{out} ErrNr: Integer): Integer;
      function  gdxOpenWrite            (const FileName: ShortString; const Producer: ShortString; var{out} ErrNr: Integer): Integer;
      function  gdxOpenWriteEx          (const FileName: ShortString; const Producer: ShortString; Compr: Integer; var{out} ErrNr: Integer): Integer;
      function  gdxResetSpecialValues   : Integer;
      function  gdxSetHasText           (SyNr: Integer): Integer;
      function  gdxSetReadSpecialValues (const AVals: TgdxSVals): Integer;
      function  gdxSetSpecialValues     (const AVals: TgdxSVals): Integer;
      function  gdxSetTextNodeNr        (TxtNr: Integer; Node: Integer): Integer;
      function  gdxSetTraceLevel        (N: Integer; const s: ShortString): Integer;
      function  gdxSymbIndxMaxLength    (SyNr: Integer; var LengthInfo: TgdxUELIndex): Integer;
      function  gdxSymbMaxLength        : Integer;
      function  gdxSymbolAddComment     (SyNr: Integer; const Txt: ShortString): Integer;
      function  gdxSymbolGetComment     (SyNr: Integer; N: Integer; var{out} Txt: ShortString): Integer;
      function  gdxSymbolGetDomain      (SyNr: Integer; var DomainSyNrs: TgdxUELIndex): Integer;
      function  gdxSymbolGetDomainX     (SyNr: Integer; var{out} DomainIDs: TgdxStrIndex): Integer;
      function  gdxSymbolDim            (SyNr: Integer): Integer;
      function  gdxSymbolInfo           (SyNr: Integer; var{out} SyId: ShortString; var{out} Dimen: Integer; var{out} Typ: Integer): Integer;
      function  gdxSymbolInfoX          (SyNr: Integer; var{out} RecCnt: Integer; var{out} UserInfo: Integer; var{out} ExplTxt: ShortString): Integer;
      function  gdxSymbolSetDomain      (const DomainIDs: TgdxStrIndex): Integer;
      function  gdxSymbolSetDomainX     (SyNr: Integer; const DomainIDs: TgdxStrIndex): Integer;
      function  gdxSystemInfo           (var{out} SyCnt: Integer; var{out} UelCnt: Integer): Integer;
      function  gdxUELMaxLength         : Integer;
      function  gdxUELRegisterDone      : Integer;
      function  gdxUELRegisterMap       (UMap: Integer; const Uel: ShortString): Integer;
      function  gdxUELRegisterMapStart  : Integer;
      function  gdxUELRegisterRaw       (const Uel: ShortString): Integer;
      function  gdxUELRegisterRawStart  : Integer;
      function  gdxUELRegisterStr       (const Uel: ShortString; var{out} UelNr: Integer): Integer;
      function  gdxUELRegisterStrStart  : Integer;
      function  gdxUMFindUEL            (const Uel: ShortString; var{out} UelNr: Integer; var{out} UelMap: Integer): Integer;
      function  gdxUMUelGet             (UelNr: Integer; var{out} Uel: ShortString; var{out} UelMap: Integer): Integer;
      function  gdxUMUelInfo            (var{out} UelCnt: Integer; var{out} HighMap: Integer): Integer;
      function  gdxCurrentDim           : Integer;
   end;

implementation
uses
   gdxdcpdef;


function gdxGetReady(var Msg: ShortString): boolean;
begin
Result := gdxdcpdef.gdxGetReady(Msg);
end;

function  gdxGetReadyX(var Msg: ShortString): boolean;
begin
Result := gdxdcpdef.gdxGetReadyX(Msg);
end;

function  gdxGetReadyD(const Dir: ShortString; var Msg: ShortString): boolean;
begin
Result := gdxdcpdef.gdxGetReadyD(Dir,Msg);
end;

function  gdxGetReadyL(const LibName: ShortString; var Msg: ShortString): boolean;
begin
Result := gdxdcpdef.gdxGetReadyL(LibName,Msg);
end;

procedure gdxSetLoadPath(const s: shortString);
begin
gdxdcpdef.gdxSetLoadPath(s);
end;

procedure gdxGetLoadPath(var s: shortString);
begin
gdxdcpdef.gdxGetLoadPath(s);
end;

procedure gdxLibraryUnload;
begin
gdxdcpdef.gdxLibraryUnload;
end;

function  gdxLibraryLoaded: boolean;
begin
Result := gdxdcpdef.gdxLibraryLoaded;
end;

constructor TGXFile.Create(var Msg: ShortString);
begin
inherited Create;
own := true;
if not gdxdcpdef.gdxCreate(pgdx, Msg) then begin
   pgdx := nil;
   if Msg = '' then
      Msg := 'Unknown error calling TGXFile.Create';
   end
else Msg := '';
end; (* TGXFile.Create *)

constructor TGXFile.CreateX(var Msg: ShortString);
begin
inherited Create;
own := true;
if not gdxdcpdef.gdxCreateX(pgdx, Msg) then begin
   pgdx := nil;
   if Msg = '' then
      Msg := 'Unknown error calling TGXFile.CreateX';
   end
else Msg := '';
end; (* TGXFile.CreateX *)

constructor TGXFile.CreateD(const Dir: ShortString; var Msg: ShortString);
begin
inherited Create;
own := true;
if not gdxdcpdef.gdxCreateD(pgdx, Dir, Msg) then begin
   pgdx := nil;
   if Msg = '' then
      Msg := 'Unknown error calling TGXFile.CreateD';
   end
 else Msg := '';
end; (* TGXFile.CreateD *)

constructor TGXFile.CreateL(const LibName: ShortString; var Msg: ShortString);
begin
inherited Create;
own := true;
if not gdxdcpdef.gdxCreateL(pgdx, LibName, Msg) then begin
   pgdx := nil;
   if Msg = '' then
      Msg := 'Unknown error calling TGXFile.CreateL';
   end
else Msg := '';
end; (* TGXFile.CreateL *)

constructor TGXFile.CreateWithHandle(p: pointer; var Msg: ShortString);
begin
inherited Create;
own := false;
pgdx := p;
if not gdxdcpdef.gdxGetReady(Msg) then begin
   pgdx := nil;
   if Msg = '' then
      Msg := 'Unknown error calling TGXFile.CreateWithHandle';
   end
else Msg := '';
end; (* TGXFile.CreateWithHandle *)

destructor TGXFile.Destroy;
begin
if own
then
   gdxdcpdef.gdxFree(pgdx);
inherited destroy;
end;

function TGXFile.gdxGetHandle: pointer;
begin
Result := pgdx;
end;

function  TGXFile.gdxGetScreenIndicator: Boolean;
begin
result := gdxdcpdef.gdxGetScreenIndicator;
end;

procedure TGXFile.gdxSetScreenIndicator(const ScrInd: Boolean);
begin
gdxdcpdef.gdxSetScreenIndicator(ScrInd);
end;

function  TGXFile.gdxGetExceptionIndicator: Boolean;
begin
result := gdxdcpdef.gdxGetExceptionIndicator;
end;

procedure TGXFile.gdxSetExceptionIndicator(const ExcInd: Boolean);
begin
gdxdcpdef.gdxSetExceptionIndicator(ExcInd);
end;

function  TGXFile.gdxGetExitIndicator: Boolean;
begin
result := gdxdcpdef.gdxGetExitIndicator;
end;

procedure TGXFile.gdxSetExitIndicator(const ExtInd: Boolean);
begin
gdxdcpdef.gdxSetExitIndicator(ExtInd);
end;

function  TGXFile.gdxGetErrorCount: Integer;
begin
result := gdxdcpdef.gdxGetErrorCount;
end;

procedure TGXFile.gdxSetErrorCount(const ecnt: Integer);
begin
gdxdcpdef.gdxSetErrorCount(ecnt);
end;

function  TGXFile.gdxGetErrorCallback: PTErrorCallBack;
begin
result := PTErrorCallBack(gdxdcpdef.gdxGetErrorCallback);
end;

procedure TGXFile.gdxSetErrorCallback(ecb: PTErrorCallBack);
begin
gdxdcpdef.gdxSetErrorCallback(TErrorCallBack(ecb));
end;


function  TGXFile.gdxAcronymAdd(const AName: ShortString; const Txt: ShortString; AIndx: Integer): Integer;
begin
result := gdxdcpdef.gdxAcronymAdd(pgdx, AName, Txt, AIndx);
end;

function  TGXFile.gdxAcronymCount: Integer;
begin
result := gdxdcpdef.gdxAcronymCount(pgdx);
end;

function  TGXFile.gdxAcronymGetInfo(N: Integer; var{out} AName: ShortString; var{out} Txt: ShortString; var{out} AIndx: Integer): Integer;
begin
result := gdxdcpdef.gdxAcronymGetInfo(pgdx, N, AName, Txt, AIndx);
end;

function  TGXFile.gdxAcronymGetMapping(N: Integer; var{out} orgIndx: Integer; var{out} newIndx: Integer; var{out} autoIndex: Integer): Integer;
begin
result := gdxdcpdef.gdxAcronymGetMapping(pgdx, N, orgIndx, newIndx, autoIndex);
end;

function  TGXFile.gdxAcronymIndex(V: Double): Integer;
begin
result := gdxdcpdef.gdxAcronymIndex(pgdx, V);
end;

function  TGXFile.gdxAcronymName(V: Double; var{out} AName: ShortString): Integer;
begin
result := gdxdcpdef.gdxAcronymName(pgdx, V, AName);
end;

function  TGXFile.gdxAcronymNextNr(NV: Integer): Integer;
begin
result := gdxdcpdef.gdxAcronymNextNr(pgdx, NV);
end;

function  TGXFile.gdxAcronymSetInfo(N: Integer; const AName: ShortString; const Txt: ShortString; AIndx: Integer): Integer;
begin
result := gdxdcpdef.gdxAcronymSetInfo(pgdx, N, AName, Txt, AIndx);
end;

function  TGXFile.gdxAcronymValue(AIndx: Integer): Double;
begin
result := gdxdcpdef.gdxAcronymValue(pgdx, AIndx);
end;

function  TGXFile.gdxAddAlias(const Id1: ShortString; const Id2: ShortString): Integer;
begin
result := gdxdcpdef.gdxAddAlias(pgdx, Id1, Id2);
end;

function  TGXFile.gdxAddSetText(const Txt: ShortString; var{out} TxtNr: Integer): Integer;
begin
result := gdxdcpdef.gdxAddSetText(pgdx, Txt, TxtNr);
end;

function  TGXFile.gdxAutoConvert(NV: Integer): Integer;
begin
result := gdxdcpdef.gdxAutoConvert(pgdx, NV);
end;

function  TGXFile.gdxClose: Integer;
begin
result := gdxdcpdef.gdxClose(pgdx);
end;

function  TGXFile.gdxDataErrorCount: Integer;
begin
result := gdxdcpdef.gdxDataErrorCount(pgdx);
end;

function  TGXFile.gdxDataErrorRecord(RecNr: Integer; var KeyInt: TgdxUELIndex; var Values: TgdxValues): Integer;
begin
result := gdxdcpdef.gdxDataErrorRecord(pgdx, RecNr, KeyInt, Values);
end;

function  TGXFile.gdxDataReadDone: Integer;
begin
result := gdxdcpdef.gdxDataReadDone(pgdx);
end;

function  TGXFile.gdxDataReadFilteredStart(SyNr: Integer; const FilterAction: TgdxUELIndex; var{out} NrRecs: Integer): Integer;
begin
result := gdxdcpdef.gdxDataReadFilteredStart(pgdx, SyNr, FilterAction, NrRecs);
end;

function  TGXFile.gdxDataReadMap(RecNr: Integer; var KeyInt: TgdxUELIndex; var Values: TgdxValues; var{out} DimFrst: Integer): Integer;
begin
result := gdxdcpdef.gdxDataReadMap(pgdx, RecNr, KeyInt, Values, DimFrst);
end;

function  TGXFile.gdxDataReadMapStart(SyNr: Integer; var{out} NrRecs: Integer): Integer;
begin
result := gdxdcpdef.gdxDataReadMapStart(pgdx, SyNr, NrRecs);
end;

function  TGXFile.gdxDataReadRaw(var KeyInt: TgdxUELIndex; var Values: TgdxValues; var{out} DimFrst: Integer): Integer;
begin
result := gdxdcpdef.gdxDataReadRaw(pgdx, KeyInt, Values, DimFrst);
end;

function  TGXFile.gdxDataReadRawFast(SyNr: Integer; DP: TDataStoreProc; var{out} NrRecs: Integer): Integer;
begin
result := gdxdcpdef.gdxDataReadRawFast(pgdx, SyNr, DP, NrRecs);
end;

function  TGXFile.gdxDataReadRawStart(SyNr: Integer; var{out} NrRecs: Integer): Integer;
begin
result := gdxdcpdef.gdxDataReadRawStart(pgdx, SyNr, NrRecs);
end;

function  TGXFile.gdxDataReadSlice(const UelFilterStr: TgdxStrIndex; var{out} Dimen: Integer; DP: TDataStoreProc): Integer;
begin
result := gdxdcpdef.gdxDataReadSlice(pgdx, UelFilterStr, Dimen, DP);
end;

function  TGXFile.gdxDataReadSliceStart(SyNr: Integer; var ElemCounts: TgdxUELIndex): Integer;
begin
result := gdxdcpdef.gdxDataReadSliceStart(pgdx, SyNr, ElemCounts);
end;

function  TGXFile.gdxDataReadStr(var{out} KeyStr: TgdxStrIndex; var Values: TgdxValues; var{out} DimFrst: Integer): Integer;
begin
result := gdxdcpdef.gdxDataReadStr(pgdx, KeyStr, Values, DimFrst);
end;

function  TGXFile.gdxDataReadStrStart(SyNr: Integer; var{out} NrRecs: Integer): Integer;
begin
result := gdxdcpdef.gdxDataReadStrStart(pgdx, SyNr, NrRecs);
end;

function  TGXFile.gdxDataSliceUELS(const SliceKeyInt: TgdxUELIndex; var{out} KeyStr: TgdxStrIndex): Integer;
begin
result := gdxdcpdef.gdxDataSliceUELS(pgdx, SliceKeyInt, KeyStr);
end;

function  TGXFile.gdxDataWriteDone: Integer;
begin
result := gdxdcpdef.gdxDataWriteDone(pgdx);
end;

function  TGXFile.gdxDataWriteMap(const KeyInt: TgdxUELIndex; const Values: TgdxValues): Integer;
begin
result := gdxdcpdef.gdxDataWriteMap(pgdx, KeyInt, Values);
end;

function  TGXFile.gdxDataWriteMapStart(const SyId: ShortString; const ExplTxt: ShortString; Dimen: Integer; Typ: Integer; UserInfo: Integer): Integer;
begin
result := gdxdcpdef.gdxDataWriteMapStart(pgdx, SyId, ExplTxt, Dimen, Typ, UserInfo);
end;

function  TGXFile.gdxDataWriteRaw(const KeyInt: TgdxUELIndex; const Values: TgdxValues): Integer;
begin
result := gdxdcpdef.gdxDataWriteRaw(pgdx, KeyInt, Values);
end;

function  TGXFile.gdxDataWriteRawStart(const SyId: ShortString; const ExplTxt: ShortString; Dimen: Integer; Typ: Integer; UserInfo: Integer): Integer;
begin
result := gdxdcpdef.gdxDataWriteRawStart(pgdx, SyId, ExplTxt, Dimen, Typ, UserInfo);
end;

function  TGXFile.gdxDataWriteStr(const KeyStr: TgdxStrIndex; const Values: TgdxValues): Integer;
begin
result := gdxdcpdef.gdxDataWriteStr(pgdx, KeyStr, Values);
end;

function  TGXFile.gdxDataWriteStrStart(const SyId: ShortString; const ExplTxt: ShortString; Dimen: Integer; Typ: Integer; UserInfo: Integer): Integer;
begin
result := gdxdcpdef.gdxDataWriteStrStart(pgdx, SyId, ExplTxt, Dimen, Typ, UserInfo);
end;

function  TGXFile.gdxGetDLLVersion(var{out} V: ShortString): Integer;
begin
result := gdxdcpdef.gdxGetDLLVersion(pgdx, V);
end;

function  TGXFile.gdxErrorCount: Integer;
begin
result := gdxdcpdef.gdxErrorCount(pgdx);
end;

function  TGXFile.gdxErrorStr(ErrNr: Integer; var{out} ErrMsg: ShortString): Integer;
begin
result := gdxdcpdef.gdxErrorStr(pgdx, ErrNr, ErrMsg);
end;

function  TGXFile.gdxFileInfo(var{out} FileVer: Integer; var{out} ComprLev: Integer): Integer;
begin
result := gdxdcpdef.gdxFileInfo(pgdx, FileVer, ComprLev);
end;

function  TGXFile.gdxFileVersion(var{out} FileStr: ShortString; var{out} ProduceStr: ShortString): Integer;
begin
result := gdxdcpdef.gdxFileVersion(pgdx, FileStr, ProduceStr);
end;

function  TGXFile.gdxFilterExists(FilterNr: Integer): Integer;
begin
result := gdxdcpdef.gdxFilterExists(pgdx, FilterNr);
end;

function  TGXFile.gdxFilterRegister(UelMap: Integer): Integer;
begin
result := gdxdcpdef.gdxFilterRegister(pgdx, UelMap);
end;

function  TGXFile.gdxFilterRegisterDone: Integer;
begin
result := gdxdcpdef.gdxFilterRegisterDone(pgdx);
end;

function  TGXFile.gdxFilterRegisterStart(FilterNr: Integer): Integer;
begin
result := gdxdcpdef.gdxFilterRegisterStart(pgdx, FilterNr);
end;

function  TGXFile.gdxFindSymbol(const SyId: ShortString; var{out} SyNr: Integer): Integer;
begin
result := gdxdcpdef.gdxFindSymbol(pgdx, SyId, SyNr);
end;

function  TGXFile.gdxGetElemText(TxtNr: Integer; var{out} Txt: ShortString; var{out} Node: Integer): Integer;
begin
result := gdxdcpdef.gdxGetElemText(pgdx, TxtNr, Txt, Node);
end;

function  TGXFile.gdxGetLastError: Integer;
begin
result := gdxdcpdef.gdxGetLastError(pgdx);
end;

function  TGXFile.gdxGetMemoryUsed: Int64;
begin
result := gdxdcpdef.gdxGetMemoryUsed(pgdx);
end;

function  TGXFile.gdxGetSpecialValues(var AVals: TgdxSVals): Integer;
begin
result := gdxdcpdef.gdxGetSpecialValues(pgdx, AVals);
end;

function  TGXFile.gdxGetUEL(UelNr: Integer; var{out} Uel: ShortString): Integer;
begin
result := gdxdcpdef.gdxGetUEL(pgdx, UelNr, Uel);
end;

function  TGXFile.gdxMapValue(D: Double; var{out} sv: Integer): Integer;
begin
result := gdxdcpdef.gdxMapValue(pgdx, D, sv);
end;

function  TGXFile.gdxOpenAppend(const FileName: ShortString; const Producer: ShortString; var{out} ErrNr: Integer): Integer;
begin
result := gdxdcpdef.gdxOpenAppend(pgdx, FileName, Producer, ErrNr);
end;

function  TGXFile.gdxOpenRead(const FileName: ShortString; var{out} ErrNr: Integer): Integer;
begin
result := gdxdcpdef.gdxOpenRead(pgdx, FileName, ErrNr);
end;

function  TGXFile.gdxOpenWrite(const FileName: ShortString; const Producer: ShortString; var{out} ErrNr: Integer): Integer;
begin
result := gdxdcpdef.gdxOpenWrite(pgdx, FileName, Producer, ErrNr);
end;

function  TGXFile.gdxOpenWriteEx(const FileName: ShortString; const Producer: ShortString; Compr: Integer; var{out} ErrNr: Integer): Integer;
begin
result := gdxdcpdef.gdxOpenWriteEx(pgdx, FileName, Producer, Compr, ErrNr);
end;

function  TGXFile.gdxResetSpecialValues: Integer;
begin
result := gdxdcpdef.gdxResetSpecialValues(pgdx);
end;

function  TGXFile.gdxSetHasText(SyNr: Integer): Integer;
begin
result := gdxdcpdef.gdxSetHasText(pgdx, SyNr);
end;

function  TGXFile.gdxSetReadSpecialValues(const AVals: TgdxSVals): Integer;
begin
result := gdxdcpdef.gdxSetReadSpecialValues(pgdx, AVals);
end;

function  TGXFile.gdxSetSpecialValues(const AVals: TgdxSVals): Integer;
begin
result := gdxdcpdef.gdxSetSpecialValues(pgdx, AVals);
end;

function  TGXFile.gdxSetTextNodeNr(TxtNr: Integer; Node: Integer): Integer;
begin
result := gdxdcpdef.gdxSetTextNodeNr(pgdx, TxtNr, Node);
end;

function  TGXFile.gdxSetTraceLevel(N: Integer; const s: ShortString): Integer;
begin
result := gdxdcpdef.gdxSetTraceLevel(pgdx, N, s);
end;

function  TGXFile.gdxSymbIndxMaxLength(SyNr: Integer; var LengthInfo: TgdxUELIndex): Integer;
begin
result := gdxdcpdef.gdxSymbIndxMaxLength(pgdx, SyNr, LengthInfo);
end;

function  TGXFile.gdxSymbMaxLength: Integer;
begin
result := gdxdcpdef.gdxSymbMaxLength(pgdx);
end;

function  TGXFile.gdxSymbolAddComment(SyNr: Integer; const Txt: ShortString): Integer;
begin
result := gdxdcpdef.gdxSymbolAddComment(pgdx, SyNr, Txt);
end;

function  TGXFile.gdxSymbolGetComment(SyNr: Integer; N: Integer; var{out} Txt: ShortString): Integer;
begin
result := gdxdcpdef.gdxSymbolGetComment(pgdx, SyNr, N, Txt);
end;

function  TGXFile.gdxSymbolGetDomain(SyNr: Integer; var DomainSyNrs: TgdxUELIndex): Integer;
begin
result := gdxdcpdef.gdxSymbolGetDomain(pgdx, SyNr, DomainSyNrs);
end;

function  TGXFile.gdxSymbolGetDomainX(SyNr: Integer; var{out} DomainIDs: TgdxStrIndex): Integer;
begin
result := gdxdcpdef.gdxSymbolGetDomainX(pgdx, SyNr, DomainIDs);
end;

function  TGXFile.gdxSymbolDim(SyNr: Integer): Integer;
begin
result := gdxdcpdef.gdxSymbolDim(pgdx, SyNr);
end;

function  TGXFile.gdxSymbolInfo(SyNr: Integer; var{out} SyId: ShortString; var{out} Dimen: Integer; var{out} Typ: Integer): Integer;
begin
result := gdxdcpdef.gdxSymbolInfo(pgdx, SyNr, SyId, Dimen, Typ);
end;

function  TGXFile.gdxSymbolInfoX(SyNr: Integer; var{out} RecCnt: Integer; var{out} UserInfo: Integer; var{out} ExplTxt: ShortString): Integer;
begin
result := gdxdcpdef.gdxSymbolInfoX(pgdx, SyNr, RecCnt, UserInfo, ExplTxt);
end;

function  TGXFile.gdxSymbolSetDomain(const DomainIDs: TgdxStrIndex): Integer;
begin
result := gdxdcpdef.gdxSymbolSetDomain(pgdx, DomainIDs);
end;

function  TGXFile.gdxSymbolSetDomainX(SyNr: Integer; const DomainIDs: TgdxStrIndex): Integer;
begin
result := gdxdcpdef.gdxSymbolSetDomainX(pgdx, SyNr, DomainIDs);
end;

function  TGXFile.gdxSystemInfo(var{out} SyCnt: Integer; var{out} UelCnt: Integer): Integer;
begin
result := gdxdcpdef.gdxSystemInfo(pgdx, SyCnt, UelCnt);
end;

function  TGXFile.gdxUELMaxLength: Integer;
begin
result := gdxdcpdef.gdxUELMaxLength(pgdx);
end;

function  TGXFile.gdxUELRegisterDone: Integer;
begin
result := gdxdcpdef.gdxUELRegisterDone(pgdx);
end;

function  TGXFile.gdxUELRegisterMap(UMap: Integer; const Uel: ShortString): Integer;
begin
result := gdxdcpdef.gdxUELRegisterMap(pgdx, UMap, Uel);
end;

function  TGXFile.gdxUELRegisterMapStart: Integer;
begin
result := gdxdcpdef.gdxUELRegisterMapStart(pgdx);
end;

function  TGXFile.gdxUELRegisterRaw(const Uel: ShortString): Integer;
begin
result := gdxdcpdef.gdxUELRegisterRaw(pgdx, Uel);
end;

function  TGXFile.gdxUELRegisterRawStart: Integer;
begin
result := gdxdcpdef.gdxUELRegisterRawStart(pgdx);
end;

function  TGXFile.gdxUELRegisterStr(const Uel: ShortString; var{out} UelNr: Integer): Integer;
begin
result := gdxdcpdef.gdxUELRegisterStr(pgdx, Uel, UelNr);
end;

function  TGXFile.gdxUELRegisterStrStart: Integer;
begin
result := gdxdcpdef.gdxUELRegisterStrStart(pgdx);
end;

function  TGXFile.gdxUMFindUEL(const Uel: ShortString; var{out} UelNr: Integer; var{out} UelMap: Integer): Integer;
begin
result := gdxdcpdef.gdxUMFindUEL(pgdx, Uel, UelNr, UelMap);
end;

function  TGXFile.gdxUMUelGet(UelNr: Integer; var{out} Uel: ShortString; var{out} UelMap: Integer): Integer;
begin
result := gdxdcpdef.gdxUMUelGet(pgdx, UelNr, Uel, UelMap);
end;

function  TGXFile.gdxUMUelInfo(var{out} UelCnt: Integer; var{out} HighMap: Integer): Integer;
begin
result := gdxdcpdef.gdxUMUelInfo(pgdx, UelCnt, HighMap);
end;

function  TGXFile.gdxCurrentDim: Integer;
begin
result := gdxdcpdef.gdxCurrentDim(pgdx);
end;

end.
