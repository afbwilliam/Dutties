// gamsxco.hpp
// Header file for C++-style (object) interface to the GAMSX library
// generated by apiwrapper for GAMS Version 24.0.2

#if ! defined(_GAMSXCO_HPP_)
#     define  _GAMSXCO_HPP_

#define GAMSXAPIVERSION 1

#if defined(UNICODE) || defined (_UNICODE)
#error Cannot run when UNICODE is defined
#endif

#include "gamsxcc.h"
/* standard includes */
#include <string>
#include <cstring>

namespace GAMS {
class GAMSX
{
public:
  GAMSX ();                  // default constructor with out init call
  GAMSX (std::string &msg);  // New object with library loading
  GAMSX (const std::string &dirname, std::string &msg); // New object with library loading from dirname
  GAMSX (const std::string &dirname, const std::string &libname, std::string &msg); // New object with library loading from dirname and libraryname
  GAMSX (gamsxHandle_t gamsxHandle, std::string &msg); // constructor if we already have a gamsxHandle
  GAMSX (gamsxHandle_t gamsxHandle, const std::string &dirname, std::string &msg); // constructor if we already have a gamsxHandle
  ~GAMSX ();                 // destructor

  int Init (std::string &msg);
  int Init (const std::string &dirname, std::string &msg);
  int Init (const std::string &dirname, const std::string &libname, std::string &msg);
  int Init (gamsxHandle_t gamsxHandle, std::string &msg);
  int Init (gamsxHandle_t gamsxHandle, const std::string &dirname, std::string &msg);
  gamsxHandle_t GetHandle ();
  inline int       RunExecDLL (void *optPtr, const std::string &sysDir, int AVerbose, std::string &Msg)
  { int rc=gamsxRunExecDLL (gamsxHandle_, optPtr, sysDir.c_str(), AVerbose, tmpS0); Msg=tmpS0; return rc; }
  inline bool       ShowError (const std::string &fNameLog, std::string &errorLine, std::string &errorTyp, std::string &gmsLine)
  { bool rc=gamsxShowError (gamsxHandle_, fNameLog.c_str(), tmpS0, tmpS1, tmpS2) != 0; errorLine=tmpS0; errorTyp=tmpS1; gmsLine=tmpS2; return rc; }
  inline void       AddBreakPoint (const std::string &fn, int lineNr)
  {  return gamsxAddBreakPoint (gamsxHandle_, fn.c_str(), lineNr);}
  inline void       ClearBreakPoints ()
  {  return gamsxClearBreakPoints (gamsxHandle_);}
  inline int       SystemInfo (int &NrSy, int &NrUel)
  {  return gamsxSystemInfo (gamsxHandle_, &NrSy, &NrUel);}
  inline int       SymbolInfo (int SyNr, std::string &SyName, std::string &SyExplTxt, int &SyDim, int &SyTyp, int &SyCount, int &SyUserInfo)
  { int rc=gamsxSymbolInfo (gamsxHandle_, SyNr, tmpS0, tmpS1, &SyDim, &SyTyp, &SyCount, &SyUserInfo); SyName=tmpS0; SyExplTxt=tmpS1; return rc; }
  inline std::string       UelName (int uel)
  { char *rc=gamsxUelName (gamsxHandle_, uel, tmpS0); return (std::string)rc; }
  inline int       FindSymbol (const std::string &SyName)
  {  return gamsxFindSymbol (gamsxHandle_, SyName.c_str());}
  inline int       DataReadRawStart (int SyNr, int &SyCount)
  {  return gamsxDataReadRawStart (gamsxHandle_, SyNr, &SyCount);}
  inline int       DataReadRaw (int Elements[], double Vals[], int &FDim)
  {  return gamsxDataReadRaw (gamsxHandle_, Elements, Vals, &FDim);}
  inline int       DataReadDone ()
  {  return gamsxDataReadDone (gamsxHandle_);}
  inline int       DataWriteRawStart (int SyNr, bool DoMerge)
  {  return gamsxDataWriteRawStart (gamsxHandle_, SyNr, DoMerge);}
  inline int       DataWriteRaw (const int Elements[], const double Vals[])
  {  return gamsxDataWriteRaw (gamsxHandle_, Elements, Vals);}
  inline int       DataWriteDone ()
  {  return gamsxDataWriteDone (gamsxHandle_);}
  inline void       RegisterCB1 (TBrkPCallBack1_t CB1, void *userMem)
  {  return gamsxRegisterCB1 (gamsxHandle_, CB1, userMem);}
  inline void       RegisterCB2 (TBrkPCallBack2_t CB2, void *userMem1, void *userMem2)
  {  return gamsxRegisterCB2 (gamsxHandle_, CB2, userMem1, userMem2);}
  inline TBrkPCallBack1_t      GetCB1 ()
  {  return gamsxGetCB1 (gamsxHandle_);}
  inline TBrkPCallBack2_t      GetCB2 ()
  {  return gamsxGetCB2 (gamsxHandle_);}
  inline void *      GetCB1UM ()
  {  return gamsxGetCB1UM (gamsxHandle_);}
  inline void *      GetCB2UM1 ()
  {  return gamsxGetCB2UM1 (gamsxHandle_);}
  inline void *      GetCB2UM2 ()
  {  return gamsxGetCB2UM2 (gamsxHandle_);}
  inline void      SWSet(const int  x)  { gamsxSWSet (gamsxHandle_, x); }
  inline bool       StepThrough()  { return gamsxStepThrough (gamsxHandle_) != 0; }
  inline void      StepThroughSet(const bool  x)  { gamsxStepThroughSet (gamsxHandle_, x); }
  inline bool       RunToEnd()  { return gamsxRunToEnd (gamsxHandle_) != 0; }
  inline void      RunToEndSet(const bool  x)  { gamsxRunToEndSet (gamsxHandle_, x); }
  inline bool       CB1Defined()  { return gamsxCB1Defined (gamsxHandle_) != 0; }
  inline bool       CB2Defined()  { return gamsxCB2Defined (gamsxHandle_) != 0; }
  static int libraryLoad(char *errBuf, int errBufLen);

 private:
  gamsxHandle_t gamsxHandle_;
  int extHandle;
  static int numInst;
  static int isLoaded;
  static int gamsxGetReady (std::string& msg);
  static int gamsxGetReady (const std::string& dir, std::string& msg);
  void create();
  void destroy();
  char *DPout[GMS_MAX_INDEX_DIM];
  char tmpS0[256], tmpS1[256], tmpS2[256];
};
};
#endif /* #if ! defined(_GAMSXCO_HPP_) */
